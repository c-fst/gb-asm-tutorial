<!DOCTYPE HTML>
<html lang="it" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GB ASM Tutorial</title>
        <meta name="robots" content="noindex" />

        <!-- Custom HTML head -->
        <meta name="twitter:card" content="summary_large_image"/>
        <meta name="twitter:site:id" content="@gbdev0"/>
        <meta property="og:title" content="GB ASM Tutorial" />
        <meta property="og:image" content="https://gbdev.io/gb-asm-tutorial/assets/banner/1200x628.png" />
        <meta property="og:site_name" content="GB ASM Tutorial"/>

        <meta name="description" content="A complete guide to programming Game Boy games in assembly.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="css/custom.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Home</a></li><li class="chapter-item affix "><a href="roadmap.html">Tabella di marcia</a></li><li class="chapter-item affix "><a href="help-feedback.html">Help</a></li><li class="chapter-item affix "><li class="part-title">Parte ‚Ö† - Hello World!</li><li class="chapter-item "><a href="part1/setup.html"><strong aria-hidden="true">1.</strong> Configurazione</a></li><li class="chapter-item "><a href="part1/hello_world.html"><strong aria-hidden="true">2.</strong> Hello World!</a></li><li class="chapter-item "><a href="part1/toolchain.html"><strong aria-hidden="true">3.</strong> Strumenti di lavoro</a></li><li class="chapter-item "><a href="part1/bin_and_hex.html"><strong aria-hidden="true">4.</strong> Binario ed esadecimale</a></li><li class="chapter-item "><a href="part1/registers.html"><strong aria-hidden="true">5.</strong> Registri</a></li><li class="chapter-item "><a href="part1/assembly.html"><strong aria-hidden="true">6.</strong> Basi di Assembly</a></li><li class="chapter-item "><a href="part1/memory.html"><strong aria-hidden="true">7.</strong> Memoria</a></li><li class="chapter-item "><a href="part1/header.html"><strong aria-hidden="true">8.</strong> The header</a></li><li class="chapter-item "><a href="part1/operations.html"><strong aria-hidden="true">9.</strong> Operazioni e flags</a></li><li class="chapter-item "><a href="part1/jumps.html"><strong aria-hidden="true">10.</strong> Salti</a></li><li class="chapter-item "><a href="part1/tracing.html"><strong aria-hidden="true">11.</strong> Tracciamento</a></li><li class="chapter-item "><div><strong aria-hidden="true">12.</strong> Grafica</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="part1/tiles.html"><strong aria-hidden="true">12.1.</strong> Tiles</a></li><li class="chapter-item "><a href="part1/palettes.html"><strong aria-hidden="true">12.2.</strong> Palette</a></li><li class="chapter-item "><a href="part1/tilemap.html"><strong aria-hidden="true">12.3.</strong> Tilemap</a></li></ol></li><li class="chapter-item "><a href="part1/wrapup.html"><strong aria-hidden="true">13.</strong> In conclusione</a></li><li class="chapter-item affix "><li class="part-title">Parte ‚Ö° - Il nostro primo gioco</li><li class="chapter-item "><a href="part2/getting-started.html"><strong aria-hidden="true">14.</strong> Per iniziare</a></li><li class="chapter-item "><a href="part2/objects.html"><strong aria-hidden="true">15.</strong> Oggetti</a></li><li class="chapter-item "><a href="part2/functions.html"><strong aria-hidden="true">16.</strong> Funzioni</a></li><li class="chapter-item "><a href="part2/input.html"><strong aria-hidden="true">17.</strong> Input</a></li><li class="chapter-item "><a href="part2/collision.html"><strong aria-hidden="true">18.</strong> Collisioni</a></li><li class="chapter-item "><a href="part2/bricks.html"><strong aria-hidden="true">19.</strong> Bricks</a></li><li class="chapter-item "><a href="part2/wip.html"><strong aria-hidden="true">20.</strong> Lavori in corso</a></li><li class="chapter-item affix "><li class="part-title">Parte ‚Ö¢ - Il nostro secondo gioco</li><li class="chapter-item "><div><strong aria-hidden="true">21.</strong> Da scrivere...</div></li><li class="spacer"></li><li class="chapter-item affix "><a href="next.html">Prossimi passi</a></li><li class="chapter-item affix "><a href="resources.html">Risorse</a></li><li class="chapter-item affix "><a href="thanks.html">Ringraziamenti</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GB ASM Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="it">Italian</a>
                          </button></li>
                        </ul>

                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("it");
                          selectedLang.parentNode.classList.add("theme-selected");

                          // The path to the root, taking the current
                          // language into account.
                          let full_path_to_root = "../";
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "en") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }
                        </script>

                        
                        <a href="https://github.com/gbdev/gb-asm-tutorial" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pagina-principale"><a class="header" href="#pagina-principale">Pagina Principale</a></h1>
<p>üëã Benvenuto in gb-asm-tutorial!
Questo tutorial ti insegner√† come programmare giochi per il Game Boy e per il Game Boy Color.</p>
<div class="box warning decorated">
<div><p>‚ö†Ô∏è</p></div>
<div>
<p>Il Game Boy ed il Game Boy Color sono quasi la stessa console, ma <strong>il Game Boy Advance √® un sistema completamente diverso</strong>.
Tuttavia, puoi comunque usarlo per giocare a giochi del GB e GBC!
Se vuoi imparare a programmare giochi per il GBC e giocarci su di un GBA, puoi comunque seguire questo tutorial; se per√≤ volessi creare giochi specificamente per il GameBoy Advance allora <a href="http://coranac.com/tonc/text">Tonc</a> √® il tutorial che fai per te.</p>
</div>
</div>
<h2 id="comandi"><a class="header" href="#comandi">Comandi</a></h2>
<p>In cima alla pagina puoi vedere alcune icone, sempre presenti se ne dovessi avere bisogno!</p>
<ul>
<li>The ‚Äúburger‚Äù <i class="fa fa-bars"></i> toggles the navigation side panel;</li>
<li>The brush <i class="fa fa-paint-brush"></i> allows selecting a different color theme;</li>
<li>The magnifying glass <i class="fa fa-search"></i> pops up a search bar;</li>
<li>The world icon <i class="fa fa-globe"></i> lets you change the language of the tutorial;</li>
<li>The printer <i class="fa fa-print"></i> gives a single-page version of the <em>entire</em> tutorial, which you can print if you want;</li>
<li>The GitHub icon <i class="fa fa-github"></i> links to the tutorial‚Äôs source repository;</li>
<li>The edit button <i class="fa fa-edit"></i> allows you to suggest changes to the tutorial, provided that you have a GitHub account.</li>
</ul>
<p>Ci sono anche delle frecce a lato della pagina (o in fondo, se sei su cellulare) per passare alla pagina successiva o precedente.</p>
<p>E con questo, per iniziare ti baster√† premere la freccia a destra :)</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Feel free to send feedback or suggestions in the form of Issues on the <a href="https://github.com/gbdev/gb-asm-tutorial">GitHub repository</a>.
We‚Äôre also looking for help for writing new lessons and improving the existing ones! Feel free to send Pull Requests and go through the Issues to see what needs to be worked on.</p>
<p>You can help translating the tutorial on <a href="https://crowdin.com/project/gb-asm-tutorial">Crowdin</a>.</p>
<h2 id="licenza"><a class="header" href="#licenza">Licenza</a></h2>
<p><strong>In breve</strong>:</p>
<ul>
<li>Code within the tutorial is essentially <strong>public domain</strong>, meaning that you are allowed to copy it freely without restrictions.</li>
<li>You are free to copy the tutorial‚Äôs contents (prose, diagrams, etc.), modify them, and share that, but you must give credit and license any copies permissively.</li>
<li>This site‚Äôs <em>source code</em> can be freely copied, but you must give a license and copyright notice.</li>
</ul>
<p><strong>Maggiori Informazioni</strong>, per maggiori informazioni sulle rispettive licenze, seguire questi link:</p>
<ul>
<li>All the code contained within the tutorial itself is licensed under <a rel="license" href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a>. <em>To the extent possible under law, all copyright and related or neighboring rights to code presented within GB ASM Tutorial have been waived.</em></li>
<li>The contents (prose, images, etc.) of this tutorial are licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</li>
<li>Code used to display and format the site is licensed under the <a href="https://github.com/gbdev/gb-asm-tutorial/blob/master/LICENSE">MIT License</a> unless otherwise specified.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tabella-di-marcia"><a class="header" href="#tabella-di-marcia">Tabella di marcia</a></h1>
<p>Il tutorial √® suddiviso in tre sezioni.
<strong>Consiglio vivamente di seguirle in ordine!</strong></p>
<p>Nella parte ‚Ö†, lanciamo il nostro primo programma ‚ÄúHello World!‚Äù, per poi analizzarlo al fine di capire come funziona il Game Boy.</p>
<p>Nella parte ‚Ö° programmiamo il nostro primo gioco, un clone di <em>Arkanoid</em>; impariamo a dare le prime istruzioni all‚Äôhardware per ottenere qualcosa che si possa definire ‚Äúgioco‚Äù.
Lungo il percorso commetteremo molti errori, ma questo servir√† anche a imparare a risolvere i problemi del nostro codice.</p>
<p>Infine, la Parte ‚Ö¢ riguarda l‚Äôuso ‚Äúavanzato‚Äù dell‚Äôhardware, dove impareremo a creare giochi ancora pi√π rifiniti e programmeremo uno ‚ÄúShoot ‚ÄôEm Up‚Äù!</p>
<div class="box tip">
<p>Spero che il tutorial funzioni per voi!!!
Ma se cos√¨ non fosse (questo formato non funziona bene per tutti, e va bene cos√¨), vi esorto a guardare <a href="resources.html">altre risorse</a>, che potrebbero fare pi√π al vostro caso.
Fa bene anche fare una pausa di tanto in tanto; sentitevi liberi di leggere al vostro ritmo e di <a href="https://gbdev.io/chat">chiedere chiarimenti</a> se qualcosa non vi √® chiaro.</p>
</div>
<hr />
<p>Purtroppo questa guida non √® ancora stata completata.
Per adesso stiamo ancora scrivendo la <strong>Parte ‚Ö°</strong>, e la Parte ‚Ö¢ verr√† subito dopo.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="help"><a class="header" href="#help">Help</a></h1>
<p>If you are stuck in a certain part of the tutorial, want some advice, or just wish to chat with us, <a href="https://gbdev.io/chat">the GBDev community chat</a> is the place to go!
The authors actively participate there so don‚Äôt be afraid to ask questions!
(The ‚ÄúASM‚Äù channel should be the most appropriate to discuss the tutorial, by the way.)</p>
<p>If you prefer email, you can reach us at <code>tutorial@&lt;domain&gt;</code>, where you replace <code>&lt;domain&gt;</code> with this website‚Äôs domain name.
Anti-spam measure, I hope you understand.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preparazione"><a class="header" href="#preparazione">Preparazione</a></h1>
<p>Per prima cosa, dobbiamo configurare il nostro ambiente di sviluppo.
Avremo bisogno di:</p>
<ol>
<li>Un ambiente POSIX</li>
<li><a href="https://rgbds.gbdev.io/install">RGBDS</a> v0.5.1 (anche se la v0.5.0 dovrebbe essere comunque compatibile)</li>
<li>GNU Make (preferibilmente una versione recente)</li>
<li>Un editor di codice</li>
<li>Un emulatore per il debug</li>
</ol>
<div class="box tip decorated">
<div><p>‚ùìüòï</p></div>
<div>
<p>Abbiamo fatto del nostro meglio per fornire queste istruzioni per l‚Äôinstallazione, ma potrebbero essere obsolete o non funzionare per qualche motivo.
In ogni caso, non preoccupatevi, siamo qui per aiutarvi: <a href="part1/../index.html#feedback">chiedi pure in GBDev</a>, e ti aiuteremo a installare tutto!</p>
</div>
</div>
<h2 id="strumenti"><a class="header" href="#strumenti">Strumenti</a></h2>
<h3 id="linux-e-macos"><a class="header" href="#linux-e-macos">Linux e macOS</a></h3>
<p>Buone notizie: hai gi√† completato il primo passo!
Dovete solo <a href="https://rgbds.gbdev.io/install">installare RGBDS</a> e forse aggiornare GNU Make.</p>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<p>Al momento della stesura di questo articolo, macOS (fino alla 11.0, l‚Äôultima release attuale) ha in dotazione un GNU Make molto datato.
√à possibile verificarlo aprendo un terminale ed eseguendo <code>make --version</code>, che dovrebbe indicare ‚ÄúGNU Make‚Äù e una data, tra le altre cose.</p>
<p>Se il vostro Make √® troppo vecchio, potete aggiornarlo usando la formula di <a href="https://brew.sh">Homebrew</a> <a href="https://formulae.brew.sh/formula/make#default"><code>make</code></a>.
Al momento in cui scriviamo, dovrebbe essere stampato un avviso che il Make aggiornato √® stato installato come <code>gmake</code>; si pu√≤ seguire il suggerimento di usarlo come <code>make</code> ‚Äúpredefinito‚Äù, oppure usare <code>gmake</code> invece di <code>make</code> in questo tutorial.</p>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<p>Una volta installato RGBDS, aprite il terminale ed eseguite il comando <code>make --version</code> per controllare la vostra versione di Make (che probabilmente √® GNU Make).</p>
<p>Se <code>make</code> non √® presente, potrebbe essere necessario installare le <code>build-essentials</code> della propria distribuzione.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>La triste verit√† √® che Windows √® un pessimo sistema operativo per noi sviluppatori; tuttavia, √® possibile installare degli strumenti che risolvano la maggior parte dei suoi problemi.</p>
<p>Su Windows 10, la scelta migliore √® <a href="https://docs.microsoft.com/en-us/windows/wsl">WSL</a>, che permette di eseguire una distribuzione Linux all‚Äôinterno di Windows.
Installate WSL 1 o WSL 2, poi una distribuzione a vostra scelta e quindi seguite nuovamente questi passaggi per la distribuzione Linux appena installata.</p>
<p>In alternativa a WSL, si pu√≤ usare <a href="https://www.msys2.org">MSYS2</a> o <a href="https://www.cygwin.com">Cygwin</a>; per poi consultare le istruzioni per l‚Äôinstallazione di Windows di [RGBDS] (https://rgbds.gbdev.io/install).
Per quanto ne so, entrambi dovrebbero fornire una versione sufficientemente aggiornata di GNU Make.</p>
<div class="box tip">
<p>Se avete programmato per altre console, come il GBA, controllate che MSYS2 non sia gi√† installato sul vostro computer.
Questo perch√© devkitPro, un popolare pacchetto di sviluppo homebrew, include MSYS2.</p>
</div>
<h2 id="editor-di-codice"><a class="header" href="#editor-di-codice">Editor di codice</a></h2>
<p>Qualsiasi editor di codice va bene; personalmente uso <a href="https://www.sublimetext.com">Sublime Text</a> con il suo <a href="https://packagecontrol.io/packages/RGBDS">pacchetto sintassi RGBDS</a>; tuttavia √® possibile usare qualsiasi editor di testo, compreso il Blocco Note se si √® abbastanza pazzi.
Awesome GBDev ha <a href="https://gbdev.io/resources#syntax-highlighting-packages">una sezione sui pacchetti per l‚Äôevidenziazione della sintassi</a> dove potete controllare se il vostro editor preferito supporta RGBDS.</p>
<h2 id="emulatore"><a class="header" href="#emulatore">Emulatore</a></h2>
<p>Usare un emulatore per giocare √® una cosa; usarlo per programmare giochi √® un‚Äôaltra.
I due aspetti che un emulatore deve soddisfare per consentire una piacevole esperienza di programmazione sono:</p>
<ul>
<li><strong>Un supporto al debug</strong>:
Se il tuo programma va in palla sulla console √® pressoch√© impossibile capire cosa sia andato storto:
non puoi controllare gli errori dal terminale, non puoi usare <code>gdb</code>, niente.
Un emulatore, al contrario, pu√≤ avere strumenti per aiutare il debug, ad esempio dandoti controllo sull‚Äôesecuzione leggere e mdoificare la memoria, e molto altro.
Senza di questi strumenti lo sviluppo sar√† tutto meno che <em>divertente</em>, fidati!</li>
<li><strong>Emulazione Precisa</strong>:
La precisione di un emulatore √® quanto questo riproduca bene il comportamento del sistema reale.
Un emulatore poco accurato andr√† anche bene per giocare (seppur spesso con un esperienza poco fluida‚Ä¶), ma se vuoi <em>programmare</em>, hai bisogno di sapere se il tuo gioco sia effettivamente compatibile con il tuo sistema.
Se sei interessato puoi leggere di pi√π a riguardo su <a href="https://arstechnica.com/?post_type=post&amp;p=44524">questo articolo di Ars Technica</a> (in particolare la sezione <q>An emulator for every game</q> in cima alla seconda pagina).
Puoi vedere e confrontare la precisione di alcuni degli emulatori GameBoy pi√π popolari sul <a href="https://daid.github.io/GBEmulatorShootout/">GB-emulator-shootout</a> di Daid. Trovi una tabella con diversi test ed i risultati per emulatore.</li>
</ul>
<p>The emulator I will be using for this tutorial is <a href="https://emulicious.net/">Emulicious</a>.
Users on all OSes can install the Java runtime to be able to run it.
Other debugging emulators are available, such as <a href="https://www.mesen.ca/">Mesen2</a>, <a href="https://bgb.bircd.org">BGB</a> (Windows/Wine only), <a href="https://sameboy.github.io">SameBoy</a> (graphical interface on macOS only); they should have similar capabilities, but accessed through different menu options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>In questa lezione inizieremo ad assemblare il nostro primo programma.
Il resto del capitolo sar√† dedicato a spiegare come e perch√© funziona.</p>
<p>Tenete presente che da ora dovremo lanciare molti comandi, quindi √® il momento di aprire una finestra del terminale.
√à buon norma creare una nuova directory (<code>mkdir gb_hello_world</code>, per esempio, poi <code>cd gb_hello_world</code> per entrare nella nuova directory).</p>
<p>Scaricate i seguenti file (cliccate con il tasto destro del mouse su ogni link, ‚ÄúSalva link con nome‚Ä¶‚Äù) e metteteli tutti in questa nuova directory:</p>
<ul>
<li><a href="part1/../assets/hello-world.asm"><code>hello-world.asm</code></a></li>
<li><a href="https://raw.githubusercontent.com/gbdev/hardware.inc/v4.0/hardware.inc"><code>hardware.inc</code></a></li>
</ul>
<p>Quindi, sempre dal terminale, all‚Äôinterno di quella directory, lanciate i tre comandi seguenti.</p>
<div class="box warning decorated">
<div><p>‚ö†Ô∏è</p></div>
<div>
<p>Per chiarezza espositiva, all‚Äôinizio di ogni comando, ho aggiunto un <code>$</code>, ma voi non digitatelo!</p>
</div>
</div>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgbasm -L -o hello-world.o hello-world.asm</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgblink -o hello-world.gb hello-world.o</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgbfix -v -p 0xFF hello-world.gb</span>
</code></pre>
<style>
	.box.danger ol {
		list-style-type: symbols(fixed "üëé" "üëç" "üëç");
	}
</style>
<div class="box danger decorated">
<div><p>‚ÄºÔ∏è</p></div>
<div>
<p>Fate attenzione agli argomenti! Alcune opzioni, come <code>-o</code>, usano l‚Äôargomento dopo di esse come parametro:</p>
<ol>
<li><code>rgbasm -L -o hello-world.asm hello-world.o</code> non funzioner√† (e potrebbe corrompere <code>hello-world.asm</code>!)</li>
<li><code>rgbasm -L hello-world.asm -o hello-world.o</code> funzioner√†</li>
<li><code>rgbasm hello-world.asm -o hello-world.o -L</code> funzioner√† anche</li>
</ol>
<p>In caso di spazi all‚Äôinterno di un argomento, √® necessario metterlo tra virgolette:</p>
<ol>
<li><code>rgbasm -L -o hello world.o hello world.asm</code> non funzioner√†</li>
<li><code>rgbasm -L -o &quot;hello world.o&quot; &quot;hello world.asm&quot;</code> funzioner√†</li>
</ol>
</div>
</div>
<p>E dunque il processo sar√† il seguente:</p>
<script id="asciicast-weljUlcp1KC5GqS9jqV62dy5m" src="https://asciinema.celforyon.fr/a/weljUlcp1KC5GqS9jqV62dy5m.js" async></script>
<p>(Se riscontrate un errore che non riuscite a risolvere da soli, non abbiate paura di <a href="part1/../index.html#feedback">chiedere</a>! Lo risolveremo insieme)</p>
<p>Congrats!
You just assembled your first Game Boy ROM!
Now, we just need to run it; open Emulicious, then go ‚ÄúFile‚Äù, then ‚ÄúOpen File‚Äù, and load <code>hello-world.gb</code>.</p>
<video controls poster="../assets/vid/hello_world.poster.png">
	<source src="../assets/vid/hello_world.webm" type="video/webm">
	<source src="../assets/vid/hello_world.mp4" type="video/mp4">
<pre><code>&lt;img src=&quot;../assets/vid/hello_world.gif&quot; alt=&quot;Video demonstration in Emulicious&quot;&gt;
</code></pre>
</video>
<p>Potreste anche prendere una flash cart (cartuccia flash) (io uso l‚Äô<a href="https://krikzz.com/store/home/47-everdrive-gb.html">EverDrive GB X5</a>, ma ci sono molte alternative), caricarci la vostra ROM e farla girare su una console vera e propria!</p>
<p><img src="part1/../assets/img/hello_dmg.jpg" alt="Immagine di Hello World in esecuzione su una console DMG reale" /></p>
<p>Bene, ora che abbiamo qualcosa che funziona, √® il momento di togliere le tende per scoprire cosa c‚Äô√® sotto‚Ä¶</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strumenti-di-lavoro"><a class="header" href="#strumenti-di-lavoro">Strumenti di lavoro</a></h1>
<p>Dunque, nella lezione precedente abbiamo scritto una piccola ROM ‚ÄúHello World!‚Äù.
Ora √® il momento di capire meglio cosa abbiamo fatto.</p>
<h2 id="rgbasm-e-rgblink"><a class="header" href="#rgbasm-e-rgblink">RGBASM e RGBLINK</a></h2>
<p>Iniziamo spiegando cosa fanno <code>rgbasm</code> e <code>rgblink</code>.</p>
<p>RGBASM √® un <em>assembler</em> (compilatore).
Il suo compito √® leggere il codice sorgente (nel nostro caso <code>hello-world.asm</code> e <code>hardware.inc</code>) e generare un file di codice che per√≤ √® incompleto:
RGBASM non sempre ha tutte le informazioni che gli servono a generare una ROM, quindi produce dei <em>file oggetto</em> che fanno da intermediari (con estensione <code>.o</code>).</p>
<p>RGBLINK √® un <em>linker</em>.
Il suo compito √® usare le informazioni dei file oggetto (che nel nostro caso √® solo uno) ed unirli (in inglese ‚Äúlink‚Äù) in una ROM.
RGBLINK potrebbe sembrare superfluo, ma √® solo perch√© la ROM che abbiamo guardato √® davvero piccola: quando nella seconda parte il nostro progetto crescer√†, la sua utilit√† sar√† pi√π apparente.</p>
<p>Quindi: Codice sorgente ‚Üí <code>rgbasm</code> ‚Üí File oggetto ‚Üí <code>rgblink</code> ‚Üí ROM, giusto?
Beh, non esattamente.</p>
<h2 id="rgbfix"><a class="header" href="#rgbfix">RGBFIX</a></h2>
<p>RGBLINK produce s√¨ una ROM, ma se la provassimo su un GameBoy non funzionerebbe.
Nelle ROM deve sempre essere presente qualcosa chiamato <em>header</em>:
questa sezione contiene <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html">informazioni sulla ROM</a>, come il nome del gioco, il nome dell‚Äôautore, se sia compatibile con il GameBoy Color ed altro.
Per il momento abbiamo impostato tutti i valori a zero nel programma per semplicit√†, ma ne riparleremo nella seconda parte del tutorial.</p>
<p>Ma nell‚Äôheader ci sono anche delle componenti importantissime:</p>
<ul>
<li>il <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0104-0133--nintendo-logo">logo Nintendo</a>,</li>
<li>la <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0148--rom-size">dimensione della ROM</a>,</li>
<li>e <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#014d--header-checksum">due valori di controllo</a> (<a href="https://it.wikipedia.org/wiki/Checksum">checksum</a>).</li>
</ul>
<p>Quando la console viene accesa viene eseguito <a href="https://github.com/ISSOtm/gb-bootroms">un programma</a> chiamato <em>ROM di avvio</em> (boot ROM) responsabile, tra l‚Äôaltro, dell‚Äôanimazione di avvio leggendo il logo di Nintendo dalla ROM.
Alla fine dell‚Äôanimazione, per√≤, la ROM di avvio controlla che il logo di Nintendo sia corretto, e interrompe l‚Äôesecuzione se non lo √®:
in pratica, se non azzecchiamo il logo il nostro gioco non partir√† mai‚Ä¶ üò¶
Questo meccanismo era per evitare la pirateria; per nostra fortuna, per√≤, <a href="https://en.wikipedia.org/wiki/Sega_v._Accolade">non √® pi√π valida</a> perci√≤ non dobbiamo preoccuparci! üòÑ</p>
<p>Allo stesso modo, la ROM di avvio calcola anche un <em><a href="https://en.wikipedia.org/wiki/Checksum">checksum</a></em> dell‚Äôintestazione, presumibilmente per garantire che non sia corrotta.
L‚Äôintestazione contiene anche una copia di questo checksum; se non corrisponde a quello calcolato dalla ROM di avvio, la ROM di avvio <strong>si blocca!</strong></p>
<p>L‚Äôheader contiene anche un checksum dell‚Äôintera ROM, ma non viene mai utilizzato.
Non costa niente ed √® una buona idea, comunque, farlo bene.</p>
<p>Infine, l‚Äôheader contiene anche la dimensione della ROM, necessaria per emulatori e dalle flash cart.</p>
<p>RGBFIX serve proprio a compilare l‚Äôheader in automatico, in particolare questi tre campi senza i quali il GameBoy non far√† funzionare il gioco.
L‚Äôopzione <code>-v</code> dice a RGBFIX di rendere <strong>v</strong>alido l‚Äôheader, inserendo il logo e calcolando le checksum.
L‚Äôopzione <code>-p 0xFF</code> invece aggiunge dei byte alla ROM finch√© non raggiunge una dimensione valida (in inglese <strong>p</strong>adding), per poi scriverla nell‚Äôheader.</p>
<p>Perfetto!
Quindi, per riassumere: <br>
codice sorgente ‚Üí <code>rgbasm</code> ‚Üí file oggetto ‚Üí <code>rgblink</code> ‚Üí ROM ‚Äúvera‚Äù ‚Üí <code>rgbfix</code> ‚Üí ROM funzionante</p>
<p>A questo punto ti potresti chiedere: perch√© non si uniscono tutti questi programmi in uno solo?
Ci sono ragioni nella storia di questi programmi, ma soprattutto RGBLINK pu√≤ fare altro (per esempio usando <code>-x</code>), e a volte RGBFIX √® usato senza che RGBLINK sia minimamente necessario.</p>
<h2 id="nomi-dei-file"><a class="header" href="#nomi-dei-file">Nomi dei file</a></h2>
<p>A RGBDS, come alla maggior parte dei programmi, non importa come chiami i file n√© l‚Äôestensione che gli dai: l‚Äôimportante √® il contenuto.
Per esempio molti usano l‚Äôestensione <code>.s</code> per il sorgente, oppure <code>.obj</code> per gli oggetti.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binario-ed-esadecimale"><a class="header" href="#binario-ed-esadecimale">Binario ed esadecimale</a></h1>
<p>Prima di passare al codice dobbiamo introdurre alcuni concetti.</p>
<p>Quando si programma ad un basso livello √® fondamentale capire bene i sistemi <em><a href="https://it.wikipedia.org/wiki/Sistema_numerico_binario">binario</a></em> ed <em><a href="https://it.wikipedia.org/wiki/esadecimale">esadecimale</a></em>.
Se gi√† conoscessi questi concetti, in fondo alla pagina ci sono delle informazioni specifiche all‚Äôuso di RGDBS.</p>
<p>Cos‚Äô√® il binario?
√à semplicemente un modo alternativo di rappresentare i numeri, in <em>base 2</em>.
Noi contiamo in <a href="https://it.wikipedia.org/wiki/decimale">base 10</a>, ovvero con 10 cifre: 0, 1, 2, 3, 4, 5, 6, 7, 8, e 9.
Le cifre hanno una funzione ben specifica:</p>
<pre><code>  42 =                       4 √ó 10   + 2
     =                       4 √ó 10^1 + 2 √ó 10^0
                                  ‚Üë          ‚Üë
    	qui usiamo 10 perch√© contiamo in base 10!

1024 = 1 √ó 1000 + 0 √ó 100  + 2 √ó 10   + 4
     = 1 √ó 10^3 + 0 √ó 10^2 + 2 √ó 10^1 + 4 √ó 10^0
       ‚Üë          ‚Üë          ‚Üë          ‚Üë
 e qui vediamo le cifre che compongono il numero!
</code></pre>
<div class="box tip decorated">
<div><p>‚ÑπÔ∏è</p></div>
<div>
<p><code>^</code> qui significa ‚Äúalla potenza di‚Äù, dove <code>X^N</code> √® uguale a moltiplicare <code>X</code> con se stesso <code>N</code> volte, e <code>X ^ 0 = 1</code>.</p>
</div>
</div>
<p>Con le cifre decimali ogni numero viene <em>scomposto</em> in maniera univoca in potenze di 10 (il <em>deci</em>male √® la base 10, ricordi?).
Ma perch√© fermarsi alle potenze di 10?
Potremmo invece usare altre basi, come la base 2
(il perch√© della base 2 sar√† spiegato pi√π avanti).</p>
<p>Il sistema binario √® in base 2, quindi ha solo due cifre (chiamate <em>bit</em>): 0 e 1.
Possiamo quindi generalizzare il principio descritto sopra e riscrivere i due numeri di prima in modo simile:</p>
<pre><code>  42 =                                                    1 √ó 32  + 0 √ó 16  + 1 √ó 8   + 0 √ó 4   + 1 √ó 2   + 0
     =                                                    1 √ó 2^5 + 0 √ó 2^4 + 1 √ó 2^3 + 0 √ó 2^2 + 1 √ó 2^1 + 0 √ó 2^0
                                                              ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë
                                          E visto che stiamo contando in base 2, vediamo dei due invece dei dieci!

1024 = 1 √ó 1024 + 0 √ó 512 + 0 √ó 256 + 0 √ó 128 + 0 √ó 64  + 0 √ó 32  + 0 √ó 16  + 0 √ó 8   + 0 √ó 4   + 0 √ó 2   + 0
     = 1 √ó 2^10 + 0 √ó 2^9 + 0 √ó 2^8 + 0 √ó 2^7 + 0 √ó 2^6 + 0 √ó 2^5 + 0 √ó 2^4 + 0 √ó 2^3 + 0 √ó 2^2 + 0 √ó 2^1 + 0 √ó 2^0
       ‚Üë          ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë         ‚Üë
</code></pre>
<p>Quindi, applicando lo stesso principio, possiamo dire che in base 2, 42 si scrive come <code>101010</code> e 1024 come <code>10000000000</code>. 
Poich√© non √® possibile distinguere tra dieci (10 decimale) e due (10 binario), l‚Äôassemblaggio RGBDS prevede numeri binari preceduti da un segno di percentuale: 10 √® dieci e %10 √® due.</p>
<p>Ok, ma perch√© proprio la base 2?
Visto che un bit pu√≤ essere solo 0 o 1, √® molto facile rappresentarlo: pu√≤ essere ‚ÄúON‚Äù o ‚ÄúOFF‚Äù, vuoto o pieno, ecc!
Se ad esempio si vuole creare una memoria da un bit basta prendere una scatola:
se √® vuota allora simboleggia uno 0; se contiene <em>qualcosa</em>, allora √® un 1.
I computer manipolano quindi principalmente numeri binari e questo ha <em>molte</em> implicazioni, come vedremo nel corso di questo tutorial.</p>
<h2 id="esadecimale"><a class="header" href="#esadecimale">Esadecimale</a></h2>
<p>Ricapitolando: il decimale non √® pratico per i computer, che si affidano invece ai numeri binari (base 2).
Ok, ma il binario √® davvero difficile da usare per noi programmatori.
Prendiamo %10000000000, ovvero 2048; mentre per scriverlo in decimale bastano solo 4 cifre, in binario ne servono 12!
E probabilmente non avete neanche notato che ho scritto uno zero di troppo!
Per fortuna arriva l‚Äôesadecimale a salvare la situazione! ü¶∏</p>
<p>La base 16 funziona esattamente come tutte le altre basi, ma con 16 cifre (chiamate ‚Äú<em>nibbles</em>‚Äù in inglese): 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, ed F.</p>
<pre><code>  42 =            2 √ó 16   + 10
     =            2 √ó 16^1 + A √ó 16^0

1024 = 4 √ó 256  + 0 √ó 16   + 0
     = 4 √ó 16^2 + 0 √ó 16^1 + 0 √ó 16^0
</code></pre>
<p>Come per il binario useremo un prefisso per indicare l‚Äôesadecimale, cio√® <code>$</code>.
Quindi, 42 = $2A e 1024 = $400.
Questo √® <em>molto</em> pi√π compatto del binario, e anche un po‚Äô pi√π del decimale; ma ci√≤ che rende l‚Äôesadecimale molto interessante √® che una sua cifra corrisponde <em>esattamente</em> a 4 bit!</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Hex</th><th style="text-align: center">Bin</th></tr></thead><tbody>
<tr><td style="text-align: center">$0</td><td style="text-align: center">%0000</td></tr>
<tr><td style="text-align: center">$1</td><td style="text-align: center">%0001</td></tr>
<tr><td style="text-align: center">$2</td><td style="text-align: center">%0010</td></tr>
<tr><td style="text-align: center">$3</td><td style="text-align: center">%0011</td></tr>
<tr><td style="text-align: center">$4</td><td style="text-align: center">%0100</td></tr>
<tr><td style="text-align: center">$5</td><td style="text-align: center">%0101</td></tr>
<tr><td style="text-align: center">$6</td><td style="text-align: center">%0110</td></tr>
<tr><td style="text-align: center">$7</td><td style="text-align: center">%0111</td></tr>
<tr><td style="text-align: center">$8</td><td style="text-align: center">%1000</td></tr>
<tr><td style="text-align: center">$9</td><td style="text-align: center">%1001</td></tr>
<tr><td style="text-align: center">$A</td><td style="text-align: center">%1010</td></tr>
<tr><td style="text-align: center">$B</td><td style="text-align: center">%1011</td></tr>
<tr><td style="text-align: center">$C</td><td style="text-align: center">%1100</td></tr>
<tr><td style="text-align: center">$D</td><td style="text-align: center">%1101</td></tr>
<tr><td style="text-align: center">$E</td><td style="text-align: center">%1110</td></tr>
<tr><td style="text-align: center">$F</td><td style="text-align: center">%1111</td></tr>
</tbody></table>
</div>
<p>Ci√≤ rende facilissimo convertire tra binario ed esadecimale, e mantenere una notazione sufficientemente compatta.
Per questo, l‚Äôesadecimale √® molto pi√π utilizzato del binario.
E non preoccuparti, puoi ancora usare il decimale üòú</p>
<p>(Nota: si potrebbe pensare che anche l‚Äôottale, cio√® la base 8, funzioni altrettanto bene; tuttavia avremo a che fare perlopi√π con unit√† di 8 bit, per le quali l‚Äôesadecimale funziona molto meglio dell‚Äôottale. Volendo, RGBDS permette di usare l‚Äôottale tramite il prefisso <code>&amp;</code>, ma non l‚Äôho mai visto usare nella pratica)</p>
<div class="box tip decorated">
<div><p>üí°</p></div>
<div>
<p>Se vi √® difficile convertire i numeri tra le diverse basi, controllate se la vostra calcolatrice ha una modalit√† ‚Äúprogrammatore‚Äù o un altro modo per convertire i numeri: la maggior parte delle calcolatrici lo ha.</p>
</div>
</div>
<h2 id="riepilogo"><a class="header" href="#riepilogo">Riepilogo</a></h2>
<ul>
<li>Nell‚Äôassembly RGBDS, il prefisso esadecimale √® <code>$</code>, mentre il prefisso binario √® <code>%</code>.</li>
<li>L‚Äôesadecimale pu√≤ essere usato come notazione ‚Äúbinaria compatta‚Äù.</li>
<li>L‚Äôuso del binario o dell‚Äôesadecimale √® utile quando i singoli bit sono importanti; altrimenti, il decimale va comunque bene.</li>
<li>Nei casi in cui i numeri iniziano a diventare troppo lunghi, RGBASM consente di inserire dei trattini bassi tra le cifre (<code>123_465</code>, <code>%10_1010</code>, <code>$DE_AD_BE_EF</code>, ecc.).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registri"><a class="header" href="#registri">Registri</a></h1>
<p>Bene!
Ora che sappiamo cosa sono i bit, cerchiamo di capire come si usano.
Non ti preoccupare, tutto questo √® per lo pi√π in preparazione alla prossima parte, dove ci butteremo finalmente nel codice vero e proprio üëÄ</p>
<p>First, if you opened Emulicious, you have been greeted with just the Game Boy screen.
So, it‚Äôs time we pop the debugger open!
Go to ‚ÄúTools‚Äù, then click ‚ÄúDebugger‚Äù, or press <kbd><kbd>F1</kbd></kbd>.
Then in the debugger‚Äôs menu, click ‚ÄúView‚Äù, then click ‚ÄúShow Addresses‚Äù</p>
<video controls poster="../assets/vid/debugger.poster.png">
	<source src="../assets/vid/debugger.webm" type="video/webm">
	<source src="../assets/vid/debugger.mp4" type="video/mp4">
<pre><code>&lt;img src=&quot;../assets/vid/debugger.gif&quot; alt=&quot;Video demonstration in Emulicious&quot;&gt;
</code></pre>
</video>
<p>Il debugger potrebbe sembrare incomprensibile all‚Äôinizio, ma non ti preoccupare: ti ci abituerai in fretta!
Per il momento guarda in alto a destra, dove c‚Äô√® un piccolo spazio intitolato <em>register viewer</em> (visualizzatore dei registri).</p>
<p><img src="part1/../assets/img/reg_viewer.png" alt="Immagine della posizione del visualizzatore di registri" /></p>
<div class="box warning decorated">
<div><p>‚ö†Ô∏è</p></div>
<div>
<p>Il visualizzatore mostra sia i <em>registri della CPU</em> che alcuni <em>registri hardware</em>.
In questa lezione parleremo solo dei registri della CPU, perci√≤ non ti preoccupare se salteremo alcuni nomi.</p>
</div>
</div>
<p>Ma cosa sono questi registri della CPU?
Ti faccio un esempio: immagina di star preparando una torta.
Ovviamente avrai una ricetta da seguire, come ad esempio ‚Äúsciogli 125g di cioccolato e 125g di burro, mescola il tutto con due uova‚Äù e cos√¨ via.
Dopo aver preso gli ingredienti, non li usi direttamente nel frigo; per comodit√†, li prenderai e li metterai su un banco da lavoro o un tavolo dove lavorarci pi√π facilmente.</p>
<p>I registri sono questo tavolo, su cui il processore poggia temporaneamente i suoi ingredienti.
Pi√π concretamente, sono dei piccoli spazi di memoria (Il GameBoy ne ha solo 10 byte, e anche le CPU moderne hanno meno di un kilobyte se non si contano i registri <a href="https://it.wikipedia.org/wiki/SIMD"><abbr title="Single Instruction, Multiple Data">SIMD</abbr></a>).
Eseguire le operazioni direttamente sulla memoria √® scomodo, sarebbe come rompere le uova nel frigo: per questo le spostiamo sul tavolo, i registri, prima di romperle.</p>
<div class="box tip decorated">
<div><p>‚ÑπÔ∏è</p></div>
<div>
<p>Ovviamente ci sono eccezioni a questa regola, come un po‚Äô tutte le regole che ti spiegheremo nel tutorial; stiamo semplificando di molto le cose per mantenerle ad un livello abbastanza facile da comprendere, perci√≤ non prendere mai queste regole troppo alla lettera.</p>
</div>
</div>
<h2 id="registri-generici"><a class="header" href="#registri-generici">Registri Generici</a></h2>
<p>A grandi linee ci sono due tipi di registri: <em>registri generici</em> e <em>registri speciali</em>.
Un registro generico (abbreviato <abbr title="inglese: General-Purpose Register">GPR</abbr>) pu√≤ essere usato per dati di qualunque tipo.
Qualche GPR ha anche delle funzioni pi√π specifiche, come vedremo pi√π in l√†; in generale per distinguerli da quelli speciali chiediti ‚Äúposso inserirci dati arbitrari?‚Äù.</p>
<p>Parleremo poi dei registri speciali;
hanno funzioni particolari che non abbiamo ancora spiegato e perci√≤ li spiegheremo quando parleremo della funzione specifica, visto che fino ad allora non ne capiremmo lo scopo.</p>
<p>La CPU del Game Boy ha sette GPR a 8 bit: <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>h</code> e <code>l</code>.
‚Äú8 bit‚Äù significa che memorizzano 8 bit.
Pertanto, possono memorizzare numeri interi da 0 a 255 (%1111_1111 alias $FF).</p>
<p>`a‚Äô √® l‚Äô<em>accumulatore</em>, e come vedremo pi√π avanti pu√≤ essere usato in modi particolari.</p>
<p>Questi registri hanno un‚Äôaltra caratteristica interessante; sono tutti (tranne <code>a</code>) <em>accoppiati</em> ad un altro registro, e queste coppie possono funzionare da registri a 16 bit: <code>BC</code>, <code>DE</code>, e <code>HL</code>.
Ma tieni sempre a mente che le coppie <em>non</em> sono indipendenti dai registri che li formano; se, ad esempio, <code>D</code> contiene 192 ($C0) ed <code>E</code> 222 ($DE) allora <code>DE</code> conterr√† 49374 ($C0DE) = <code>D √ó 0x100 + E</code>.
Tutte le altre coppie funzionano allo stesso modo.</p>
<p>Quindi, cambiare il valore di <code>DE</code> modifica sia quello di <code>D</code> che di <code>E</code> allo stesso tempo e modificare <code>D</code> o <code>E</code> cambier√† il valore della coppia <code>DE</code>.
Ok, ma come facciamo a usare questi registri?
√à il momento di dare un‚Äôocchiata all‚ÄôAssembly!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primi-passi-in-assembly"><a class="header" href="#primi-passi-in-assembly">Primi passi in Assembly</a></h1>
<p>Bene, ora che sappiamo cosa <em>fanno</em> gli strumenti, vediamo che lingua parla RGBASM.
Prender√≤ una breve porzione dell‚Äôinizio di <code>hello-world.asm</code>, in modo da essere d‚Äôaccordo sui numeri di riga e da avere un‚Äôevidenziazione della sintassi anche se il vostro editor non la supporta.</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;hardware.inc&quot;

SECTION &quot;Header&quot;, ROM0[$100]

	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header

EntryPoint:
	; Shut down audio circuitry
	ld a, 0
	ld [rNR52], a
</code></pre>
<p>Analizziamolo insieme.
Sappi che per il momento salteremo <em>molte</em> delle funzionalit√† di RGBASM; se fossi curioso di saperne di pi√π, dovrai aspettare fino alla seconda o terza parte oppure leggere la <a href="https://rgbds.gbdev.io/docs">documentazione</a>.</p>
<h2 id="commenti"><a class="header" href="#commenti">Commenti</a></h2>
<p>Iniziamo dalla riga 10, che dovrebbe essere grigia nel riquadro qui sopra.
I punti e virgola <code>;</code> indicano un <em>commento</em>.
I commenti (che finiscono alla fine della riga) sono <em>ignorati</em> dall‚Äôassembler, indipendentemente dal contenuto.
Come vedi alla riga 7, puoi anche inserire commenti dopo aver scritto altro.</p>
<p>I commenti sono molto importanti in tutti i linguaggi di programmazione: ti aiutano a descrivere la funzione del tuo codice.
√à pi√π o meno la differenza tra ‚Äúscalda il forno fino a 180¬∞C‚Äù e ‚Äúscalda il forno a 180¬∞C, se lo scaldassi di pi√π la torta brucerebbe‚Äù.
I commenti sono utilissimi in ogni linguaggio di programmazione, ma in Assembly sono ancora pi√π importanti: infatti, il codice Assembly √® molto pi√π astratto.</p>
<h2 id="istruzioni"><a class="header" href="#istruzioni">Istruzioni</a></h2>
<p>Il codice Assembly √® basato completamente su righe.
Ogni riga contiene:</p>
<ul>
<li>una <em>direttiva</em>, che d√† istruzioni all‚Äôassembler, oppure</li>
<li>un‚Äô<em>istruzione</em><sup class="footnote-reference"><a href="#instr_directive">1</a></sup>, diretta al GameBoy e quindi copiata direttamente in ROM.</li>
</ul>
<p>Parleremo delle direttive pi√π avanti, per ora concentriamoci sulle istruzioni: per esempio, nello snippet qui sopra, ignoreremo le righe 1 (<code>INCLUDE</code>), 7 (<code>ds</code>) e 3 (<code>SECTION</code>).</p>
<p>Per continuare l‚Äôanalogia con la preparazione di una torta, le istruzioni sono come i passi di una ricetta.
Il processore (<abbr title="Central Processing Unit">CPU</abbr>) esegue un‚Äôistruzione alla volta. Istruzione dopo istruzione‚Ä¶ dopo un po‚Äô si arriva al risultato!
Come cuocere una torta, disegnare ‚ÄúHello World‚Äù, oppure mostrarti un tutorial sull‚ÄôAssembly del GameBoy!</p>
<p>Le istruzioni sono composte da una <em>mnemonica</em>, un nome con cui le puoi invocare, e dei <em>parametri</em>, ovvero su cosa va eseguita l‚Äôoperazione.
Ad esempio: in ‚Äúsciogli il cioccolato ed il burro in una padella‚Äù l‚Äôistruzione √® <em>tutta la frase</em>; la mnemonica sarebbe l‚Äô<em>azione</em>, ovvero sciogli, mentre i parametri sono gli <em>oggetti</em> della frase (cioccolato, burro, padella).</p>
<p>Cominciamo dall‚Äôistruzione pi√π importante: <strong><code>ld</code></strong>.
<code>ld</code> sta per ‚Äú<abbr title="LoaD in inglese">carica</abbr>‚Äù, e semplicemente copia i dati contenuti nel secondo parametro (‚Äú<a href="https://en.wikipedia.org/wiki/Sides_of_an_equation"><abbr title="Right-Hand Side">RHS</abbr></a>‚Äù) nel primo (‚Äú<a href="https://en.wikipedia.org/wiki/Sides_of_an_equation"><abbr title="Left-Hand Side">LHS</abbr></a>‚Äù).
Per esempio, guardiamo la riga 11 del nostro programma, <code>ld a, 0</code>: copia (‚Äúcarica‚Äù) il numero zero nel registro <code>a</code><sup class="footnote-reference"><a href="#ld_imm_from">2</a></sup>.
Per fare un altro esempio, a riga 33 troviamo <code>ld a, b</code>: significa semplicemente ‚Äúcopia il valore di <code>b</code> in <code>a</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Istruzione</th><th>Mnemonica</th><th>Effetto</th></tr></thead><tbody>
<tr><td>Carica</td><td><code>ld</code></td><td>Copia dei valori</td></tr>
</tbody></table>
</div>
<div class="box tip decorated">
<div><p>‚ÑπÔ∏è</p></div>
<div>
<p>Per via delle limitazioni del processore, non tutte le combinazioni di operandi sono valide per <code>ld</code> e per molte altre istruzioni; ne parleremo in seguito, quando arriver√† il momento di scrivere il nostro codice.</p>
</div>
</div>
<div class="box tip decorated">
<div><p>ü§î</p></div>
<div>
<p>RGBDS ha una <a href="https://rgbds.gbdev.io/docs/gbz80.7">lista delle istruzioni del GameBoy</a> che vale la pena tenere tra i preferiti, e che si pu√≤ anche consultare dal terminale scrivendo <code>man 7 gbz80</code> se RGBDS √® installato sulla propria macchina (tranne su Windows‚Ä¶).
Le descrizioni che trovate in quella pagina sono pi√π concise: sono intese come un promemoria, non come un tutorial.</p>
</div>
</div>
<h2 id="direttive"><a class="header" href="#direttive">Direttive</a></h2>
<p>Quindi, in un certo senso, le istruzioni sono destinate al processore del GameBoy mentre i commenti sono destinati al programmatore.
Ma alcune righe non sono n√© l‚Äôuna n√© l‚Äôaltra cosa, e sono invece dei metadati destinati a RGBDS stesso.
Queste sono chiamate <em>direttive</em> e il nostro ‚ÄúHello World‚Äù ne contiene tre.</p>
<h3 id="includere-un-altro-file"><a class="header" href="#includere-un-altro-file">Includere un altro file</a></h3>
<pre><code class="language-rgbasm linenos">INCLUDE &quot;hardware.inc&quot;
</code></pre>
<p>La riga 1 <em>include</em> <code>hardware.inc</code><sup class="footnote-reference"><a href="#hw_inc_directives">3</a></sup>.
<code>Include</code>ndo un file √® come se copiassimo il suo contenuto alla riga dove inseriamo la direttiva.</p>
<p>Cos√¨ facendo, si pu√≤ riciclare facilmente il codice in diversi file: se, ad esempio, due file <code>a.asm</code> e <code>b.asm</code> includono <code>hardware.inc</code> basta modificare il file perch√© le modifiche si applichino ad <code>a.asm</code> e <code>b.asm</code>.
Se invece copiassi a mano il contenuto di <code>hardware.inc</code> in <code>a.asm</code> e <code>b.asm</code> dovresti modificare il contenuto di entrambi ogni volta che vuoi apportare un cambiamento, che non √® solo uno spreco di tempo ma aumenta la possibilit√† di commettere errori.</p>
<p><code>hardware.inc</code> definisce alcune costanti molto utili per interfacciarsi con l‚Äôhardware del GameBoy.
Le costanti non sono altro che dei nomi a cui √® assegnato un valore: scrivere una costante equivale a scrivere il valore che le √® assegnato.
Questo torna molto utile: √® molto pi√π semplice ricordare il registro ‚Äú<strong>LCD</strong> <strong>C</strong>ontrol‚Äù (impostazioni dello schermo) col nome <code>rLCDC</code> piuttosto che ricordare l‚Äôindirizzo <code>$FF40</code>.</p>
<p>Parleremo delle costanti in modo pi√π approfondito nella Parte ‚Ö°.</p>
<h3 id="sezioni"><a class="header" href="#sezioni">Sezioni</a></h3>
<p>Spieghiamo innanzitutto che cos‚Äô√® una ‚Äúsezione‚Äù, poi vedremo che cosa fa la riga 3.</p>
<p>Una sezione rappresenta un intervallo contiguo di memoria che, di base, finisce da <em>qualche</em> parte non nota in anticipo.
Se si vuole vedere dove finisce ogni sezione si pu√≤ chiedere a RGBLINK di generare un ‚Äúfile mappa‚Äù con l‚Äôopzione <code>-m</code>:</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgblink hello-world.o -m hello-world.map</span>
</code></pre>
<p>‚Ä¶e possiamo vedere, per esempio, dove √® finita la sezione <code>&quot;Tilemap&quot;</code>:</p>
<pre><code>  SECTION: $05a6-$07e5 ($0240 bytes) [&quot;Tilemap&quot;]
</code></pre>
<p>Le sezioni non possono essere divise da RGBDS, che √® utile ad esempio per il codice poich√© il processore esegue le istruzioni una dopo l‚Äôaltra (a parte con i salti, che vedremo pi√π avanti).
Va trovato il giusto equilibrio per il numero di sezioni: non troppe ma neanche troppo poche, anche se in genere non ha molta importanza fino a quando non si inizia a parlare di banche di memoria.</p>
<p>Quindi, per ora, assumiamo che una sezione debba contenere cose che ‚Äúvanno insieme‚Äù dal punto di vista topico, ed esaminiamo una delle nostre.</p>
<pre><code class="language-rgbasm linenos start=3">SECTION &quot;Header&quot;, ROM0[$100]
</code></pre>
<p>Quindi!
Cosa fa questa riga?
Altro non √® che la dichiarazione di una nuova sezione; tutte le istruzioni e i dati dopo questa riga e fino alla successiva dichiarazione <code>SECTION</code> saranno inseriti in questa sezione appena creata.
Prima della prima direttiva <code>SECTION</code> non c‚Äô√® una sezione ‚Äúattiva‚Äù: scrivere dati o codice al di fuori di una sezione ci dar√† l‚Äôerrore <code>Cannot output data outside of a SECTION</code>.</p>
<p>Il nome della nuova sezione √® ‚Äú<code>Header</code>‚Äù.
I nomi delle sezioni possono contenere qualsiasi carattere (e anche essere vuoti, se si vuole) e devono essere unici<sup class="footnote-reference"><a href="#nome_sezione">4</a></sup>.
La parola chiave <code>ROM0</code> indica a quale ‚Äútipo di memoria‚Äù appartiene la sezione (<a href="https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.5#SECTIONS">ecco un elenco</a>).
Ne parleremo nella Parte ‚Ö°.</p>
<p>Dove dice <code>[100$]</code> invece √® pi√π interessante, perch√© √® un‚Äôindicazione speciale per questa sezione.
Se ricordi, prima abbiamo detto che:</p>
<blockquote>
<p>Una sezione [‚Ä¶], di base, finisce da <em>qualche</em> parte non nota in anticipo.</p>
</blockquote>
<p>Per√≤ alcune parti della memoria sono speciali, e quindi a volte √® necessario che una sezione specifica copra un intervallo di memoria specifico.
Per permetterlo, RGBASM ha la sintassi <code>[addr]</code> che <em>forza</em> l‚Äôindirizzo iniziale della sezione a essere <code>addr</code>.</p>
<p>In questo caso, l‚Äôintervallo di memoria $100-$14F √® speciale perch√© √® l‚Äôintestazione della ROM.
Parleremo dell‚Äôintestazione tra un paio di lezioni, ma per il momento basta sapere che <strong>non</strong> dobbiamo inserire n√© codice n√© dati in quello spazio.
E come facciamo?
Innanzitutto, iniziamo una sezione all‚Äôindirizzo $100 e poi dobbiamo riservare un po‚Äô di spazio.</p>
<h3 id="lasciare-spazio"><a class="header" href="#lasciare-spazio">Lasciare spazio</a></h3>
<pre><code class="language-rgbasm linenos start=5">	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>La riga 7 afferma di ‚Äúfare spazio per l‚Äôintestazione‚Äù, di cui ho parlato brevemente poco sopra.
Per ora, concentriamoci su ci√≤ che <code>ds</code> fa effettivamente.</p>
<p><code>ds</code> √® usato per allocare <em>staticamente</em> della memoria.
Riserva un certo numero di byte, che sono impostati ad un certo valore dato.
Il primo argomento di <code>ds</code>, in questo caso <code>$150 - @</code>, √® <em>quanti byte riservare</em>.
Il secondo argomento (che √® opzionale), in questo caso <code>0</code>, √® <em>il valore a cui impostare ogni byte riservato</em><sup class="footnote-reference"><a href="#ds_pattern">5</a></sup>.</p>
<p>Vedremo perch√© questi byte devono essere riservati in un paio di lezioni.</p>
<p>√à importante notare che il primo argomento √® un‚Äô<em>espressione</em>.
RGBDS (fortunatamente!) supporta l‚Äôinserimento di espressioni arbitrarie pressoch√© ovunque.
Quest‚Äôespressione √® una semplice sottrazione: $150 meno <code>@</code>, che √® un simbolo speciale che sta per ‚Äúl‚Äôindirizzo in memoria attuale‚Äù.</p>
<div class="box tip">
<p>Un simbolo √® essenzialmente ‚Äúun nome associato a un valore‚Äù, di solito un numero.
Nel corso dell‚Äôesercitazione esploreremo i diversi tipi di simboli, a partire dalle etichette nella prossima sezione.</p>
<p>Un simbolo numerico utilizzato in un‚Äôespressione viene sostituito dal suo valore, che dev‚Äôessere noto al momento della compilazione della ROM; in particolare, non pu√≤ dipendere dal contenuto di alcun registro.</p>
</div>
<p>Ma vi potreste stare chiedendo cosa siano questi ‚Äúindirizzi di memoria‚Äù di cui continuo a parlare.
Vediamo subito!</p>
<hr />
<div class="footnote-definition" id="instr_directive"><sup class="footnote-definition-label">1</sup>
<p>Tecnicamente le istruzioni in RGBASM sono implementate come direttive, che in pratica scrivono la loro forma codificata nella ROM; ma in questo momento non vale la pena di tirare fuori la distinzione tra le istruzioni nel codice sorgente e quelle nella ROM finale.</p>
</div>
<div class="footnote-definition" id="ld_imm_from"><sup class="footnote-definition-label">2</sup>
<p>Il lettore curioso potrebbe chiedersi da <em>dove</em> venga copiato il valore. La risposta √® semplicemente che il byte cosiddetto &quot;immediato&quot; ($00 in questo esempio) √® memorizzato nella ROM <em>immediat</em>amente dopo il byte del codice dell‚Äôistruzione, ed √® questo valore che viene copiato in <code>a</code>.
Torneremo su questo punto pi√π avanti, quando parleremo di come vengono codificate le istruzioni.</p>
</div>
<div class="footnote-definition" id="hw_inc_directives"><sup class="footnote-definition-label">3</sup>
<p>Lo stesso <code>hardware.inc</code> contiene altre direttive, in particolare per definire molti simboli.
Saranno trattate molto pi√π avanti, quindi non esamineremo ancora <code>hardware.inc</code>.</p>
</div>
<div class="footnote-definition" id="sect_name"><sup class="footnote-definition-label">6</sup>
<p>I nomi delle sezioni devono essere univoci per le sezioni ‚Äúsemplici‚Äù, mentre funzionano in modo diverso con le sezioni ‚Äúunificate‚Äù e ‚Äúa frammenti‚Äù di cui parleremo pi√π avanti.</p>
</div>
<div class="footnote-definition" id="ds_pattern"><sup class="footnote-definition-label">5</sup>
<p>In realt√†, da RGBASM 0.5.0, <code>ds</code> si pu√≤ usare con un <em>elenco</em> di byte, e ripeter√† la sequenza per il numero di byte necessario.
Questo complica un po‚Äô la spiegazione, quindi per ora l‚Äôho omesso.
Inoltre, se il parametro di <code>ds</code> viene omesso il suo valore assume quello predefinito specificato con l‚Äôopzione <code>-p</code> di RGBASM.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memoria"><a class="header" href="#memoria">Memoria</a></h1>
<div class="box tip decorated">
<div><p>üéâ</p></div>
<div>
<p>Congratulazioni, avete appena finito le lezioni pi√π difficili del tutorial!
Dal momento che avete le basi, d‚Äôora in poi vedremo codice sempre pi√π concreto.</p>
</div>
</div>
<p>Se guardiamo alla riga 29 leggiamo <code>ld a, [de]</code>.
Stando a quanto abbiamo appena appreso, questo copia un valore nel registro <code>a</code>‚Ä¶ ma da dove?
Cosa significano queste parentesi?
Per rispondere dobbiamo parlare della <em>memoria</em>.</p>
<h2 id="cos√®-una-memoria"><a class="header" href="#cos√®-una-memoria">Cos‚Äô√® una memoria?</a></h2>
<p>Lo scopo della memoria √® quello di immagazzinare informazioni.
Su un foglio di carta o su una lavagna si possono scrivere lettere per memorizzare, ad esempio, la lista della spesa.
Ma cosa si pu√≤ memorizzare nella memoria di un computer?
La risposta a questa domanda √® <em>corrente</em><sup class="footnote-reference"><a href="#memoria_magnetica">1</a></sup>.
La memoria del computer √® costituita da piccole celle in grado di immagazzinare corrente.
Ma, come abbiamo visto nella lezione sul binario, la presenza o l‚Äôassenza di corrente pu√≤ essere utilizzata per codificare i numeri binari!</p>
<p>Per farla breve: la memoria <strong>immagazzina numeri</strong>.
Difatti la memoria √® una <em>lunga</em> lista di numeri, memorizzati in celle.
Per identificare in modo univoco ogni cella, le viene assegnato un numero (e che altro!) chiamato <em>indirizzo</em>.
Come i numeri civici!
La prima cella ha l‚Äôindirizzo 0, poi l‚Äôindirizzo 1, 2 e cos√¨ via.
Sul Game Boy ogni cella contiene <em>8 bit</em>, cio√® un <em>byte</em>.</p>
<p>Quante cellule ci sono?
In realt√† questa √® una domanda trabocchetto‚Ä¶</p>
<h2 id="i-tanti-tipi-di-memoria"><a class="header" href="#i-tanti-tipi-di-memoria">I tanti tipi di memoria</a></h2>
<p>Nel Game Boy sono presenti diversi circuiti di memoria, ma possiamo suddividerli in due categorie: <abbr title="Read-Only Memory">ROM</abbr> e <abbr title="Random Access Memory">RAM</abbr><sup class="footnote-reference"><a href="#rom_ram_and">2</a></sup>.
ROM indica semplicemente la memoria su cui non √® possibile scrivere<sup class="footnote-reference"><a href="#rom_ro">3</a></sup>, e RAM la memoria su cui √® possibile scrivere.</p>
<p>Per via del loro funzionamento il processore ed i circuiti di memoria possono utilizzare un solo numero per gli indirizzi.
Torniamo all‚Äôanalogia dei ‚Äúnumeri civici‚Äù: ogni circuito di memoria √® una strada, con la sua serie di numeri, ma il processore non ha idea di cosa sia una strada, si occupa solo di numeri civici.
Per consentire al processore di parlare con pi√π circuiti serve una sorta di ‚Äúservizio postale‚Äù, il <em>selezionatore di circuito</em> (‚Äúchip selector‚Äù in inglese), che ha il compito di tradurre i numeri civici del processore in una via ed un numero civico effettivi.</p>
<p>Ad esempio, supponiamo che sia stata stabilita una convenzione per cui gli indirizzi da 0 a 1999 vanno agli indirizzi 0‚Äì1999 del circuito A, 2000‚Äì2999 allo 0‚Äì999 del circuito B e 3000‚Äì3999 allo 0‚Äì999 del circuito C.
Quindi, se il processore chiede il byte all‚Äôindirizzo 2791, il selettore di chip chieder√† al circuito B il byte al <em>suo</em> indirizzo 791 ed inoltrer√† la risposta al processore.</p>
<p>Poich√© gli indirizzi trattati dal processore non corrispondono direttamente a quelli dei circuiti si parla di indirizzi <em>logici</em> (qui, quelli del processore) e di indirizzi <em>fisici</em> (qui, quelli dei circuiti), e la corrispondenza √® chiamata <em>mappa di memoria</em> (‚Äúmemory map‚Äù in inglese).
Poich√© stiamo programmando il processore ci occuperemo solo di indirizzi <strong>logici</strong>, ma √® fondamentale tenere presente che indirizzi diversi possono essere supportati da circuiti di memoria diversi, poich√© ogni circuito ha caratteristiche uniche.</p>
<p>Pu√≤ sembrare complicato, quindi ecco un riassunto:</p>
<ul>
<li>La memoria contiene numeri, ognuno dei quali sul Game Boy √® ad 8 bit.</li>
<li>Si accede alla memoria byte per byte e la cella a cui si accede √® determinata da un <em>indirizzo</em>, che √® semplicemente un numero.</li>
<li>Il processore tratta tutta la memoria come se fosse uniforme, ma esistono diversi circuiti di memoria ognuno con le proprie caratteristiche.</li>
</ul>
<h3 id="mappa-di-memoria-del-game-boy"><a class="header" href="#mappa-di-memoria-del-game-boy">Mappa di memoria del Game Boy</a></h3>
<p>Adesso rispondiamo alla domanda che ci aveva portato a questa sezione: quante celle di memoria ci sono sul Game Boy?
Ora possiamo riformulare meglio questa domanda come ‚Äúquanti indirizzi logici ci sono?‚Äù o ‚Äúquanti indirizzi fisici ci sono in totale?‚Äù.</p>
<p>Gli indirizzi logici, che sono solo numeri, sono a 16 bit sul Game Boy.
Pertanto, ci sono 2^16 = 65536 indirizzi logici, da $0000 a $FFFF.
Ma quanti sono gli indirizzi fisici?
Ecco una mappa della memoria <a href="https://gbdev.io/pandocs/Memory_Map.html">per gentile concessione di Pan Docs</a> (anche se la semplificher√≤ un po‚Äô):</p>
<div class="table-wrapper"><table><thead><tr><th>Inizio</th><th>Fine</th><th>Nome</th><th>Descrizione</th></tr></thead><tbody>
<tr><td>$0000</td><td>$7FFF</td><td>ROM</td><td>La ROM del gioco, fornita dalla cartuccia.</td></tr>
<tr><td>$8000</td><td>$9FFF</td><td>VRAM</td><td>RAM Video, dove viene memorizzata e organizzata la grafica.</td></tr>
<tr><td>$A000</td><td>$BFFF</td><td>SRAM</td><td>RAM di Salvataggio, fornita opzionalmente da certe cartucce per salvare i dati.</td></tr>
<tr><td>$C000</td><td>$DFFF</td><td>WRAM</td><td>RAM di lavoro, RAM ad uso generico in cui il gioco pu√≤ memorizzare i dati.</td></tr>
<tr><td>$FE00</td><td>$FE9F</td><td>OAM</td><td>Object Attribute Memory, dove vengono memorizzati gli ‚Äúoggetti‚Äù.</td></tr>
<tr><td>$FF00</td><td>$FF7F</td><td>I/O</td><td>N√© ROM n√© RAM, ma √® qui che si controlla la console.</td></tr>
<tr><td>$FF80</td><td>$FFFE</td><td>HRAM</td><td>High RAM, una piccola porzione di RAM generica a cui si accede pi√π velocemente.</td></tr>
<tr><td>$FFFF</td><td>$FFFF</td><td>IE</td><td>Un solo byte di I/O separato dal resto per qualche motivo.</td></tr>
</tbody></table>
</div>
<p>$8000 + $2000 + $2000 + $2000 + $A0 + $80 + $7F + 1 fanno in totale $E1A0, ovvero 57760 byte di memoria che si possono <em>effettivamente</em> usare.
E a questo punto potreste chiedervi: ‚ÄúE i restanti 7776 byte? Cosa succede quando provo ad usarli?‚Äù; la risposta √®: ‚ÄúDipende, √® complicato; evitate di accedervi‚Äù.</p>
<h2 id="etichette"><a class="header" href="#etichette">Etichette</a></h2>
<p>Ok, tutto questo √® molto bello, ma non vi aspetterete certo che io tenga in mente tutti questi indirizzi per conto mio, giusto??
Beh, non temere, perch√© abbiamo le etichette!</p>
<p>Le etichette sono <a href="https://rgbds.gbdev.io/docs/v0.5.1/rgbasm.5#SYMBOLS">simboli</a> che in pratica permettono di assegnare un nome a un indirizzo di memoria.
Un‚Äôetichetta viene dichiarata come alla riga 9 (<code>EntryPoint:</code>): all‚Äôinizio della riga si scrive il nome dell‚Äôetichetta, seguito da due punti, ed essa si riferir√† al byte immediatamente successivo.
Quindi, per esempio, <code>EntryPoint</code> si riferisce al <code>ld a, 0</code> subito dopo (pi√π precisamente, al primo byte di quell‚Äôistruzione, ma ci arriveremo quando ci arriveremo).</p>
<div class="box tip">
<p>Se si sbircia all‚Äôinterno di <code>hardware.inc</code>, si vedr√† che, per esempio, <code>rNR52</code> non √® definito come un‚Äôetichetta.
Questo √® perch√© queste sono <em>costanti</em>, di cui parleremo pi√π in l√†; visto che si usano in modo quasi identico alle etichette, per il momento le considereremo uguali.</p>
</div>
<p>Scrivere il nome di un‚Äôetichetta equivale a scrivere l‚Äôindirizzo del byte a cui fa riferimento (con alcune eccezioni che vedremo nella Parte ‚Ö°).
Per esempio, si consideri la <code>ld de, Tiles</code> alla riga 25.
<code>Tiles</code> (riga 64) si riferisce al primo byte dei dati delle mattonelle; se assumiamo che i dati delle mattonelle finiscano per essere memorizzati a partire da $0193, allora <code>ld de, Tiles</code> √® equivalente a <code>ld de, $0193</code>!</p>
<h2 id="cosa-sono-queste-parentesi"><a class="header" href="#cosa-sono-queste-parentesi">Cosa sono queste parentesi?</a></h2>
<p>Bene, siamo arrivati a questo punto perch√© volevamo sapere cosa significano le parentesi in <code>ld a, [de]</code>.
In pratica possono essere lette come ‚Äúall‚Äôindirizzo‚Ä¶‚Äù.
Per esempio, <code>ld a, b</code> pu√≤ essere letto come ‚Äúcopia in <code>a</code> il valore memorizzato in <code>b</code>‚Äù; <code>ld a, [$5414]</code> sarebbe letto come ‚Äúcopia in <code>a</code> il valore memorizzato all‚Äôindirizzo $5414‚Äù, e <code>ld a, [de]</code> sarebbe letto come ‚Äúcopia in <code>a</code> il valore memorizzato all‚Äôindirizzo <code>de</code>‚Äù.
Aspettate, cosa significa?
Beh, se <code>de</code> contiene il valore $5414, allora <code>ld a, [de]</code> far√† la stessa cosa di <code>ld a, [$5414]</code>.</p>
<div class="box tip">
<p>Se avete familiarit√† con il C, queste parentesi sono sostanzialmente il modo in cui viene implementato l‚Äôoperatore di dereferenziazione.</p>
</div>
<h3 id="hli"><a class="header" href="#hli"><code>hli</code></a></h3>
<p>Un lettore attento avr√† notato il <code>ld [hli], a</code> appena sotto il <code>ld a, [de]</code> che abbiamo appena studiato.
<code>[de]</code> ha senso perch√© √® una delle coppie di registri che abbiamo visto un paio di lezioni fa, ma <code>[hli]</code>?
In realt√† √® una notazione speciale, che pu√≤ essere scritta anche come <code>[hl+]</code>.
Funziona come <code>[hl]</code>, ma <code>hl</code> viene <em>incrementato</em> subito dopo l‚Äôaccesso alla memoria.
<code>[hld]</code>/<code>[hl-]</code> √® lo specchio di questa, <em>decrementando</em> <code>hl</code> invece di incrementarlo.</p>
<h2 id="un-esempio"><a class="header" href="#un-esempio">Un esempio</a></h2>
<p>Quindi, se osserviamo le prime due istruzioni di <code>CopyTiles</code>:</p>
<pre><code class="language-rgbasm linenos start=29">	ld a, [de]
	ld [hli], a
</code></pre>
<p>‚Ä¶ possiamo vedere che stiamo copiando il byte in memoria <em>puntato</em> da <code>de</code> (cio√® il cui indirizzo √® contenuto in <code>de</code>) nel byte puntato da <code>hl</code>.
Qui, <code>a</code> serve come memoria temporanea, poich√© la CPU non √® in grado di eseguire direttamente <code>ld [hl], [de]</code>.</p>
<p>Gi√† che ci siamo, esaminiamo il resto di <code>.copyTiles</code> nelle lezioni successive!</p>
<hr />
<div class="footnote-definition" id="memory_magnetic"><sup class="footnote-definition-label">4</sup>
<p>In realt√†, questo dipende molto dal tipo di memoria.
Molte memorie oggi utilizzano la memoria magnetica, ma per mantenere la spiegazione semplice e per fare un parallelo con la spiegazione del binario data in precedenza, supponiamo che venga utilizzata la corrente.</p>
</div>
<div class="footnote-definition" id="rom_ram_e"><sup class="footnote-definition-label">5</sup>
<p>Esistono altri tipi di memoria, come la memoria flash o l‚ÄôEEPROM, ma solo la flash √® stata utilizzata sul Game Boy, e solo per una manciata di giochi; quindi possiamo dimenticarci di loro.</p>
</div>
<div class="footnote-definition" id="rom_ro"><sup class="footnote-definition-label">3</sup>
<p>No, davvero!
La ROM a maschera viene creata letteralmente bucando uno strato di silicio con l‚Äôacido, e ad esempio la ROM di avvio della console √® fatta di transistor cablati all‚Äôinterno del die della CPU.
Buona fortuna a scriverci!
<br>
Il termine ‚ÄúROM‚Äù viene a volte (erroneamente) utilizzato per indicare i chip di ‚Äúmemoria persistente‚Äù, come la memoria flash, la cui funzionalit√† di scrittura √® stata disabilitata.
La maggior parte delle cartucce Game Boy bootleg / ‚Äúrepro‚Äù che si possono trovare al giorno d‚Äôoggi contengono effettivamente la flash; questo √® il motivo per cui √® possibile riflasharle utilizzando hardware specializzato, mentre le cartucce originali non possono esserlo.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="header"><a class="header" href="#header">Header</a></h1>
<p>Torniamo a una certa riga vicino all‚Äôinizio di <code>hello-world.asm</code>.</p>
<pre><code class="language-rgbasm linenos start=7">	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>Che cos‚Äô√® questa misteriosa testata, perch√© le stiamo facendo spazio e altre domande trovano risposta in questa lezione!</p>
<h2 id="qual-√®-lintestazione"><a class="header" href="#qual-√®-lintestazione">Qual √® l‚Äôintestazione?</a></h2>
<p>La prima cosa da fare √® spiegare cos‚Äô√® l‚Äôheader.
√à la regione di memoria da $0104 a $014F (inclusi).
Contiene metadati sulla ROM, come il titolo, la compatibilit√† con il Game Boy Color, le dimensioni,
due checksum e, cosa interessante, il logo Nintendo che viene visualizzato durante l‚Äôanimazione di accensione.</p>
<div class="box tip">
<p>Queste e altre informazioni sono disponibili <a href="https://gbdev.io/pandocs/The_Cartridge_Header">nei documenti Pan</a>.</p>
</div>
<p>√à interessante notare che la maggior parte delle informazioni contenute nell‚Äôheader non ha importanza nell‚Äôhardware reale (la dimensione della ROM √® determinata solo dalla capacit√† del chip ROM nella cartuccia, non dal byte dell‚Äôheader).
In effetti, alcuni prototipi di ROM hanno informazioni errate sull‚Äôintestazione!</p>
<p>La maggior parte dell‚Äôintestazione veniva utilizzata solo dal reparto di produzione di Nintendo per sapere quali componenti inserire nella cartuccia quando si pubblicava una ROM.
Pertanto, solo le ROM inviate a Nintendo dovevano avere un‚Äôintestazione completamente corretta; le ROM utilizzate per i test interni dovevano solo superare i controlli della ROM di avvio, spiegati pi√π avanti.</p>
<p>Tuttavia, nella nostra epoca ‚Äúmoderna‚Äù, l‚Äôintestazione √® molto importante.
Gli emulatori (compresi gli emulatori hardware come le flashcard) devono emulare l‚Äôhardware presente nella cartuccia.
Essendo l‚Äôheader l‚Äôunica fonte di informazioni sull‚Äôhardware che la cartuccia della ROM dovrebbe contenere, si basano su alcuni dei valori presenti nell‚Äôheader.</p>
<h2 id="rom-di-avvio"><a class="header" href="#rom-di-avvio">ROM di avvio</a></h2>
<p>L‚Äôheader √® intimamente legato alla cosiddetta ** ROM di avvio**.</p>
<p>The most observant and/or nostalgic of you may have noticed the lack of the boot-up animation and the Game Boy‚Äôs signature ‚Äúba-ding!‚Äù in Emulicious.
When the console powers up, the CPU does not begin executing instructions at address $0100 (where our ROM‚Äôs entry point is), but at $0000.</p>
<p>Tuttavia, in quel momento, un piccolo programma chiamato <em>boot ROM</em>, masterizzato all‚Äôinterno del silicio della CPU, viene ‚Äúsovrapposto‚Äù alla nostra ROM!
La ROM di avvio √® responsabile dell‚Äôanimazione di avvio, ma controlla anche l‚Äôintestazione della ROM!
In particolare, verifica che i checksum del logo Nintendo e dell‚Äôheader siano corretti; se uno dei due controlli fallisce, la ROM di avvio si <em>blocca</em> intenzionalmente e il nostro gioco non potr√† mai essere eseguito :(</p>
<div class="box tip">
<p class="box-title">Per i curiosi</p><p>√à possibile trovare una descrizione pi√π dettagliata di ci√≤ che fa la ROM di avvio <a href="https://gbdev.io/pandocs/Power_Up_Sequence">nei Pan Docs</a>, nonch√© una spiegazione del controllo del logo.
Attenzione, per√≤, si tratta di un argomento piuttosto avanzato.</p>
<p>If you want to enable the boot ROMs in Emulicious, you must obtain a copy of the boot ROM(s), whose SHA256 checksums can be found <a href="https://github.com/ISSOtm/gb-bootroms/blob/master/sha256sums.txt">in their disassembly</a> for verification.
If you wish, you can also compile <a href="https://github.com/LIJI32/SameBoy#compilation">SameBoy‚Äôs boot ROMs</a> and use those instead, as a free-software substitute.</p>
<p>Then, in Emulicious‚Äô options, go to the <code>Options</code> tab, then <code>Emulation</code>‚Üí<code>Game Boy</code>, and choose which of GB and/or GBC boot roms you want to set.
Finally, set the path(s) to the boot ROM(s) you wish to use, and click <code>Open</code>.
Now, just reset the emulator, and voil√†!</p>
</div>
<p>Un‚Äôintestazione viene tipicamente definita ‚Äúvalida‚Äù se supera i controlli della ROM di avvio e ‚Äúnon valida‚Äù in caso contrario.</p>
<h2 id="rgbfix-1"><a class="header" href="#rgbfix-1">RGBFIX</a></h2>
<p>RGBFIX √® il terzo componente di RGBDS, il cui scopo √® scrivere l‚Äôintestazione di una ROM.
√à separato da RGBLINK in modo da poter essere usato come strumento indipendente.
Il suo nome deriva dal fatto che RGBLINK di solito non produce una ROM con un‚Äôintestazione valida, quindi la ROM deve essere ‚Äúaggiustata‚Äù prima di essere pronta per la produzione.</p>
<p>RGBFIX ha <a href="https://rgbds.gbdev.io/docs/rgbfix.1">un mucchio di opzioni</a> per impostare varie parti dell‚Äôintestazione; ma le uniche due che usiamo qui sono <code>-v</code>, che produce un‚Äôintestazione <strong>v</strong>alida (quindi, <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0104-0133---nintendo-logo">logo Nintendo</a> e <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#014d---header-checksum">checksums</a> corretti), e <code>-p¬†0xFF</code>, che <strong>p</strong>a la ROM alla prossima dimensione valida (usando $FF come byte di riempimento), e scrive il valore appropriato nel <a href="https://gbdev.io/pandocs/The_Cartridge_Header.html#0148---rom-size">byte di dimensione della ROM</a>.</p>
<p>Se si guarda ad altri progetti, si possono trovare invocazioni di RGBFIX con pi√π opzioni, ma queste due dovrebbero essere quasi sempre presenti.</p>
<h2 id="allora-qual-√®-il-problema-di-questa-linea"><a class="header" href="#allora-qual-√®-il-problema-di-questa-linea">Allora, qual √® il problema di questa linea?</a></h2>
<p>Giusto!
Questa linea.</p>
<pre><code class="language-rgbasm linenos start=7">	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>Vediamo cosa succede se lo rimuoviamo (o lo commentiamo).</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgbasm -L -o hello-world.o hello-world.asm</span>
<span class="console-line hljs-meta"></span><span class="language-bash">rgblink -o hello-world.gb -n hello-world.sym hello-world.o</span>
</code></pre>
<p>(Non sto intenzionalmente eseguendo RGBFIX; vedremo perch√© tra poco).</p>
<p><img src="part1/../assets/img/bad_warnings.png" alt="‚ÄúQuesta rom non funzionerebbe su un vero gameboy.‚Äù" /></p>
<p>As I explained, RGBFIX is responsible for writing the header, so we should use it to fix this exception.</p>
<pre><code><span class="console-line hljs-meta"></span><span class="language-bash">rgbfix -v -p 0xFF hello-world.gb</span>
warning: Overwrote a non-zero byte in the Nintendo logo
warning: Overwrote a non-zero byte in the header checksum
warning: Overwrote a non-zero byte in the global checksum
</code></pre>
<p><em>Sono sicuro che questi avvisi non sono nulla di cui preoccuparsi‚Ä¶</em>
(A seconda della versione di RGBDS in uso, √® possibile che siano stati visualizzati avvisi diversi, o addirittura nessuno).</p>
<p>Let‚Äôs run the ROM, click on Console on the debugger‚Äôs bottom window, press <kbd><kbd>F5</kbd></kbd> a few times, and‚Ä¶</p>
<figure>
  <img src="part1/../assets/img/invalid_opcode.png" alt="Screenshot of Emulicious' debugger, PC won't advance past $0105">
  <figcaption>
    When the console reads "Executing illegal instruction", you <i>might</i> have screwed up somewhere.
  </figcaption>
</figure>
<p><img src="part1/../assets/img/fine.png" alt="‚ÄúThis is fine‚Äù meme strip" /></p>
<p>Ok, allora, cos‚Äô√® successo?</p>
<p>Come si pu√≤ vedere dallo screenshot, PC si trova a $0105.
Cosa sta facendo l√¨?</p>
<p>‚Ä¶Oh, <code>EntryPoint</code> √® a $0103.
Quindi il <code>jp</code> a $0100 √® andato l√¨ e ha iniziato a eseguire le istruzioni (<code>3E CE</code> √® la forma grezza di <code>ld a, $CE</code>), ma poi $ED non codifica alcuna istruzione valida, quindi la CPU si blocca.</p>
<p>Ma perch√© <code>EntryPoint</code> √® l√¨?
Come avrete capito dagli avvisi stampati da RGBFIX, esso <em>sovrascrive</em> l‚Äôarea dell‚Äôintestazione nella ROM.
Tuttavia, RGBLINK non √® a conoscenza dell‚Äôintestazione (perch√© RGBLINK non √® usato solo per generare ROM!), quindi √® necessario riservare esplicitamente spazio per l‚Äôarea dell‚Äôintestazione.</p>
<div class="box danger decorated">
<div><p>ü•¥</p></div>
<div>
<p>Dimenticare di riservare questo spazio e far s√¨ che un pezzo di codice o di dati finisca l√¨ e poi venga sovrascritto √® un errore comune dei principianti che pu√≤ lasciare perplessi.
Fortunatamente, RGBFIX dalla versione 0.5.1 avverte quando rileva questo errore, come mostrato sopra.</p>
</div>
</div>
<p>Cos√¨, preveniamo disastri come questo:</p>
<pre><code class="language-rgbasm linenos start=3">SECTION &quot;Header&quot;, ROM0[$100]

	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>La direttiva <code>ds</code> sta per ‚Äúdefine space‚Äù e consente di riempire un intervallo di memoria.
Questa riga specifica riempie tutti i byte da $103 a $14F (inclusi) con il valore $00.
Poich√© parti diverse di codice e/o di dati non possono sovrapporsi, questo assicura che l‚Äôintervallo di memoria dell‚Äôintestazione possa essere sovrascritto in modo sicuro da RGBFIX e che nessun altro venga accidentalmente sovrascritto.</p>
<p>Potrebbe non essere ovvio come questo <code>ds</code> finisca per riempire quello specifico intervallo di memoria.
Il <code>jp</code> a 3 byte copre gli indirizzi di memoria $100, $101 e $102.<br />
(Iniziamo da $100 perch√© √® dove si trova la <code>SECTION</code> definita manualmente).<br />
Quando RGBASM elabora la direttiva <code>ds</code>, <code>@</code> (che √® un simbolo speciale che valuta ‚Äúl‚Äôindirizzo corrente‚Äù) ha quindi il valore $103, quindi riempie <code>$150 - $103 = $4D</code> byte con zeri, quindi $103, $104, ‚Ä¶, $14E, $14F.</p>
<h2 id="bonus-il-ciclo-infinito"><a class="header" href="#bonus-il-ciclo-infinito">Bonus: il ciclo infinito</a></h2>
<p>(Questo non √® propriamente collegato all‚Äôintestazione, ma devo spiegarlo da qualche parte e questo √® un posto come un altro).</p>
<p>Ci si potrebbe anche chiedere a cosa serva il ciclo infinito alla fine del codice.</p>
<pre><code class="language-rgbasm">Done:
	jp Done
</code></pre>
<p>Semplicemente, la CPU non smette mai di eseguire istruzioni; quindi, quando il nostro piccolo Hello World √® finito e non c‚Äô√® pi√π nulla da fare, dobbiamo comunque dare alla CPU un po‚Äô di lavoro: quindi le facciamo fare nulla, per sempre.</p>
<p>Non possiamo lasciare che la CPU se ne vada, perch√© inizierebbe a eseguire altre parti della memoria come codice, con il rischio di bloccarsi.
(Per verificare: rimuovete o commentate queste due righe, compilate nuovamente la ROM](hello_world.md) e vedete cosa succede).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operazioni-e-flag"><a class="header" href="#operazioni-e-flag">Operazioni e flag</a></h1>
<p>Va bene, sappiamo come passare i valori, ma copiare semplicemente i numeri non √® divertente; vogliamo modificarli!</p>
<p>La CPU GB non fornisce tutte le operazioni sotto il sole (per esempio, non esiste un‚Äôistruzione di moltiplicazione), ma possiamo programmarle da soli con ci√≤ che abbiamo.
Parliamo di alcune delle operazioni di cui dispone; per ora ne ometter√≤ alcune non utilizzate in Hello World.</p>
<h2 id="aritmetica"><a class="header" href="#aritmetica">Aritmetica</a></h2>
<p>Le istruzioni aritmetiche pi√π semplici supportate dalla CPU sono <code>inc</code> e <code>dec</code>, che rispettivamente INCrementano e DECrementano il loro operando.
(Se non siete sicuri, ‚Äúincrementare‚Äù significa ‚Äúaggiungere 1‚Äù e ‚Äúdecrementare‚Äù significa ‚Äúsottrarre 1‚Äù).
Quindi, per esempio, il <code>dec bc</code> alla riga 32 di <code>hello-world.asm</code> sottrae semplicemente 1 da <code>bc</code>.</p>
<p>Ok, bene!
Possiamo per√≤ andare un po‚Äô pi√π veloci?
Certo che s√¨, con <code>add</code> e <code>sub</code>!
Questi rispettivamente aggiungono e sottraggono valori arbitrari (una costante o un registro).
Nessuno dei due viene usato nel tutorial, ma c‚Äô√® un parente di <code>sub</code>: avete notato il piccolo <code>cp</code> alla riga 17?
<code>cp</code> permette di confrontare i valori.
Funziona come <code>sub</code>, ma scarta il risultato invece di riscriverlo.
‚ÄúAspettate, quindi non fa nulla?‚Äù, vi chiederete; beh, aggiorna le <strong>flag</strong>.</p>
<h2 id="flag"><a class="header" href="#flag">Flag</a></h2>
<p>√à arrivato il momento di parlare del registro speciale (ve lo ricordate?) <code>f</code>, per, beh, <em>flag</em>.
Il registro <code>f</code> contiene 4 bit, chiamati ‚Äúflag‚Äù, che vengono aggiornati a seconda dei risultati di un‚Äôoperazione.
Questi 4 flag sono:</p>
<div class="table-wrapper"><table><thead><tr><th>Nome</th><th>Descrizione</th></tr></thead><tbody>
<tr><td>Z</td><td>Flag di zero</td></tr>
<tr><td>N</td><td>Addizione/sottrazione</td></tr>
<tr><td>H</td><td>Mezzo-carry</td></tr>
<tr><td>C</td><td>Carry</td></tr>
</tbody></table>
</div>
<p>S√¨, esiste un flag chiamato ‚ÄúC‚Äù e un registro chiamato ‚Äúc‚Äù, e <strong>sono cose diverse e non correlate</strong>.
Questo rende la sintassi un po‚Äô confusa all‚Äôinizio, ma vengono sempre usati in contesti diversi, quindi basta farci caso.</p>
<p>Per ora dimentichiamo N e H; concentriamoci su Z e C.
Z √® il flag pi√π semplice: viene impostato quando il risultato di un‚Äôoperazione √® 0 e viene azzerato altrimenti.
C viene impostato quando un‚Äôoperazione <em>sopravanza</em> (overflow) o <em>sottoavanza</em>.</p>
<p>Che cos‚Äô√® un overflow?
Prendiamo la semplice istruzione <code>add a, 42</code>.
Questa istruzione aggiunge semplicemente 42 al contenuto del registro <code>a</code> e scrive il risultato in <code>a</code>.</p>
<pre><code class="language-rgbasm">    ld a, 200
    add a, 42
</code></pre>
<p>Alla fine di questo snippet, <code>a</code> √® uguale a 200 + 42 = 242, fantastico!
Ma se invece scrivessi questo?</p>
<p>``rgbasm
ld a, 220
add a, 42</p>
<pre><code>
Si potrebbe pensare che `a` sia uguale a 220 + 42 = 262, ma non sarebbe corretto.
Ricordate che `a` √® un registro a 8 bit, *pu√≤ memorizzare solo otto bit di informazione*!
E se dovessimo scrivere 262 in binario, otterremmo %100000110, che richiede almeno 9 bit...
Quindi cosa succede?
Semplicemente, il nono bit viene *perduto* e il valore che otteniamo √® %00000110 = 6. Questo si chiama *overflow*.
Questo si chiama *overflow*: dopo l'**aggiunta**, otteniamo un valore **pi√π piccolo** di quello con cui abbiamo iniziato.

Possiamo anche fare l'opposto con `sub`, e &amp;mdash;per esempio&amp;mdash; sottrarre 42 da 6; come sappiamo, per tutti gli `X` e `Y`, `X + Y - Y = X`, e abbiamo appena visto che 220 + 42 = 6 (questo √® chiamato *modulo 256 aritmetico*, a proposito); quindi, 6 - 42 = (220 + 42) - 42 = 220.
Questo si chiama *underflow*: dopo la **sottrazione**, otteniamo un valore **superiore** a quello di partenza.

Quando si esegue un'operazione, si imposta il flag di carry se si √® verificato un overflow o un underflow e lo si cancella altrimenti.
(Vedremo pi√π avanti che non tutte le operazioni aggiornano il flag di riporto).

::: punta Sintesi

- Possiamo sommare e sottrarre numeri.
- Il flag Z ci permette di sapere se il risultato √® 0.
- Tuttavia, i registri possono memorizzare solo un intervallo limitato di numeri interi.
- L'uscita da questo intervallo √® chiamata **overflow** o **underflow**, rispettivamente per l'addizione e la sottrazione.
- Il flag C ci permette di sapere se si √® verificato uno dei due casi.

:::

## Confronto

Parliamo ora di come `cp` viene utilizzato per confrontare i numeri.
Ecco un ripasso: `cp` sottrae il suo operando da `a` e aggiorna i flag di conseguenza, ma non scrive il risultato.
Possiamo usare i flag per controllare le propriet√† dei valori confrontati e vedremo nella prossima lezione come usarli.

L'interazione pi√π semplice √® quella con il flag Z.
Se √® impostato, sappiamo che la sottrazione ha prodotto 0, cio√® `a - operando == 0`; quindi, `a == operando`!
Se non √® impostato, allora sappiamo che `a = operando'.

Ok, controllare l'uguaglianza √® bello, ma potremmo anche voler eseguire dei *confronti*.
Non preoccupatevi, perch√© il flag di riporto serve proprio a questo!
Quando si esegue una sottrazione, il flag di riporto viene impostato quando il risultato scende sotto lo 0, ma √® solo un modo elegante per dire &quot;diventa negativo&quot;!

Quindi, quando il flag di riporto viene impostato, sappiamo che `a - operando &lt; 0`, quindi che `a &lt; operando`...!
E, al contrario, sappiamo che se non √® impostato, `a &gt;= operando`.
Ottimo!

## Riassunto dell'istruzione

Istruzione | Mnemonico | Effetto
------------|----------|---------------------------------------------
Add | `add` | Aggiunge valori a `a`
Subtract | `sub` | Sottrae valori da `a`
Compare | `cp` | Confronta valori con quelli contenuti in `a`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="salti"><a class="header" href="#salti">salti</a></h1>
<div class="box tip">
<p>Una volta terminata questa lezione, saremo in grado di capire tutto di <code>CopyTiles</code>!</p>
</div>
<p>Finora tutto il codice che abbiamo visto era lineare: veniva eseguito dall‚Äôalto verso il basso.
Ma questo non √® sufficiente: a volte √® necessario eseguire alcune azioni in base al risultato di altre (‚Äúse le cr√™pes iniziano ad attaccarsi, ungi di nuovo la padella‚Äù), e a volte √® necessario eseguire azioni ripetutamente (‚Äúse √® rimasta della pastella, ripeti dal passo 5‚Äù).</p>
<p>Entrambe le cose implicano una lettura non lineare della ricetta.
Nell‚Äôassemblaggio, questo si ottiene con i <em>salti</em>.</p>
<p>La CPU dispone di un registro speciale chiamato ‚ÄúPC‚Äù, che sta per Program Counter.
Esso contiene l‚Äôindirizzo dell‚Äôistruzione in corso di esecuzione<sup class="footnote-reference"><a href="#pc_updates">1</a></sup>, come se si tenesse a mente il numero del passo della ricetta che si sta eseguendo.
Il PC aumenta automaticamente quando la CPU legge le istruzioni, quindi ‚Äúper impostazione predefinita‚Äù vengono lette in sequenza; tuttavia, le istruzioni di salto consentono di scrivere un valore diverso nel PC, saltando di fatto a un‚Äôaltra parte del programma.
Da qui il nome.</p>
<p>Ok, allora parliamo di queste istruzioni di salto, che ne dite?
Ce ne sono quattro:</p>
<div class="table-wrapper"><table><thead><tr><th>Istruzione</th><th>Mnemonico</th><th>Effetto</th></tr></thead><tbody>
<tr><td>Jump</td><td><code>jp</code></td><td>Salta l‚Äôesecuzione a una locazione</td></tr>
<tr><td>Jump Relativo</td><td><code>jr</code></td><td>Salta a una locazione vicina</td></tr>
<tr><td>Call</td><td><code>call</code></td><td>Chiama una subroutine</td></tr>
<tr><td>Return</td><td><code>ret</code></td><td>Ritorna da una subroutine</td></tr>
</tbody></table>
</div>
<p>Per ora ci concentreremo su <code>jp</code>.
<code>jp</code>, come quello della riga 5, imposta semplicemente PC al suo argomento, saltando l‚Äôesecuzione a quel punto.
In altre parole, dopo l‚Äôesecuzione di <code>jp EntryPoint</code> (riga 5), l‚Äôistruzione successiva eseguita √® quella sotto <code>EntryPoint</code> (riga <!-- should be 9 + 1 --> 16).</p>
<div class="box tip decorated">
<div><p>ü§î</p></div>
<div>
<p>Ci si potrebbe chiedere a cosa serva questo specifico <code>jp</code>.
Non preoccupatevi, vedremo pi√π avanti perch√© √® necessario.</p>
</div>
</div>
<h2 id="salti-condizionati"><a class="header" href="#salti-condizionati">Salti condizionati</a></h2>
<p>Passiamo ora alla parte <em>davvero</em> interessante.
Esaminiamo il ciclo responsabile della copia delle tessere:</p>
<pre><code class="language-rgbasm linenos start=24">	; Copy the tile data
	ld de, Tiles
	ld hl, $9000
	ld bc, TilesEnd - Tiles
CopyTiles:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTiles
</code></pre>
<div class="box tip">
<p>Non preoccupatevi se non capite bene quanto segue, perch√© lo vedremo in azione nella prossima lezione.
Se avete problemi, provate ad andare alla prossima lezione e guardate il codice eseguito passo per passo; poi, tornando qui, dovrebbe avere pi√π senso.</p>
</div>
<p>Per prima cosa, copiamo <code>Tiles</code>, l‚Äôindirizzo del primo byte dei dati delle piastrelle, in <code>de</code>.
Quindi, impostiamo <code>hl</code> a $9000, che √® l‚Äôindirizzo in cui inizieremo a copiare i dati delle mattonelle.
<code>ld bc, TilesEnd - Tiles</code> imposta <code>bc</code> sulla lunghezza dei dati delle tile: <code>TilesEnd</code> √® l‚Äôindirizzo del primo byte <em>dopo</em> i dati delle mattonelle, quindi sottraendo <code>Tiles</code> a questo si ottiene la lunghezza.</p>
<p>Quindi, in pratica:</p>
<ul>
<li><code>de</code> contiene l‚Äôindirizzo da cui verranno copiati i dati;</li>
<li><code>hl</code> contiene l‚Äôindirizzo in cui verranno copiati i dati;</li>
<li><code>bc</code> contiene il numero di byte da copiare.</li>
</ul>
<p>Arriviamo quindi al ciclo principale.
Leggiamo un byte dalla sorgente (riga 29) e lo scriviamo nella destinazione (riga 30).
Incrementiamo i puntatori alla destinazione (tramite l‚Äôimplicito <code>inc hl</code> fatto da <code>ld [hli], a</code>) e alla sorgente (riga 31), in modo che la successiva iterazione del ciclo elabori il byte successivo.</p>
<p>Ecco la parte interessante: poich√© abbiamo appena copiato un byte, significa che ne abbiamo uno in meno, quindi <code>dec</code>.
(Abbiamo gi√† visto <code>dec</code> due lezioni fa; per rinfrescare la memoria, si tratta semplicemente di diminuire di uno il valore memorizzato in <code>bc</code>).
Poich√© <code>bc</code> contiene la quantit√† di byte che devono ancora essere copiati, √® banale capire che dobbiamo semplicemente ripetere l‚Äôoperazione se <code>bc</code> ;= 0.</p>
<div class="box danger decorated">
<div><p>üòì</p></div>
<div>
<p><code>dec</code> di solito aggiorna i flag, ma sfortunatamente <code>dec bc</code> non lo fa, quindi dobbiamo controllare se <code>bc</code> ha raggiunto 0 manualmente.</p>
</div>
</div>
<p><code>ld a, b</code> e <code>or a, c</code> ‚ÄúOR bitwise‚Äù <code>b</code> e <code>c</code> insieme; per ora √® sufficiente sapere che lascia 0 in <code>a</code> se e solo se <code>bc</code> == 0.
E <code>or</code> aggiorna il flag Z!
Quindi, dopo la riga 34, il flag Z √® impostato se e solo se <code>bc</code> == 0, cio√® se dobbiamo uscire dal ciclo.</p>
<p>Ed √® qui che entrano in gioco i salti condizionati!
√à possibile ‚Äúprendere‚Äù incondizionatamente un salto a seconda dello stato dei flag.</p>
<p>Le ‚Äúcondizioni‚Äù sono quattro:</p>
<div class="table-wrapper"><table><thead><tr><th>Nome</th><th>Mnemonico</th><th>Descrizione</th></tr></thead><tbody>
<tr><td>Zero</td><td><code>z</code></td><td>Z √® impostato (l‚Äôultima operazione ha avuto un risultato pari a 0)</td></tr>
<tr><td>Non zero</td><td><code>nz</code></td><td>Z non √® impostato (l‚Äôultima operazione ha avuto un risultato non nullo)</td></tr>
<tr><td>Carry</td><td><code>c</code></td><td>C √® impostato (l‚Äôultima operazione ha traboccato)</td></tr>
<tr><td>No carry</td><td><code>nc</code></td><td>C non √® impostato (l‚Äôultima operazione non ha traboccato)</td></tr>
</tbody></table>
</div>
<p>Quindi, <code>jp nz, CopyTiles</code> pu√≤ essere letto come ‚Äúse il flag Z non √® impostato, allora salta a <code>CopyTiles</code>‚Äù.
Poich√© stiamo saltando <em>all‚Äôindietro</em>, ripeteremo di nuovo le istruzioni: abbiamo appena creato un <strong>loop</strong>!</p>
<p>Ok, abbiamo parlato molto del codice e lo abbiamo visto girare, ma non abbiamo visto <em>come</em> gira.
Guardiamo la magia che si svolge al rallentatore nella prossima lezione!</p>
<hr />
<div class="footnote-definition" id="pc_updates"><sup class="footnote-definition-label">1</sup>
<p>Non esattamente; le istruzioni possono essere lunghe diversi byte e PC si incrementa dopo aver letto ogni byte.
In particolare, ci√≤ significa che quando un‚Äôistruzione finisce di essere eseguita, PC punta all‚Äôistruzione successiva.
Comunque, √® pi√π o meno ‚Äúda dove la CPU sta leggendo‚Äù, ma √® meglio mantenere le cose semplici ed evitare di parlare della codifica delle istruzioni per ora.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tracciamento"><a class="header" href="#tracciamento">Tracciamento</a></h1>
<p>Avete mai sognato di essere un mago?
Beh, questo non vi dar√† poteri magici, ma vediamo come gli emulatori possono essere usati per controllare il tempo!</p>
<p>Per prima cosa, assicuratevi di mettere a fuoco la finestra del debugger.
Spieghiamo innanzitutto il layout del debugger:
<img src="part1/../assets/img/debugger.png" alt="" />
In alto a sinistra c‚Äô√® il visualizzatore del codice, in basso a sinistra c‚Äô√® il visualizzatore dei dati, in alto a destra ci sono alcuni registri (come abbiamo visto nella <a href="part1/registers.html">lezione sui registri</a>) e in basso a destra c‚Äô√® il visualizzatore dello stack.
Che cos‚Äô√® lo stack?
Risponderemo a questa domanda un po‚Äô pi√π tardi‚Ä¶ nella Parte ‚Ö° üòÖ</p>
<h2 id="impostazione"><a class="header" href="#impostazione">Impostazione</a></h2>
<p>For now, let‚Äôs focus on the code viewer.</p>
<p>As Emulicious can load our source code, our code‚Äôs labels and comments are automatically shown in the debugger.
As we have seen a couple of lessons ago, labels are merely a convenience provided by RGBASM, but they are not part of the ROM itself.
In other emulators, it is very much inconvenient to debug without them, and so sym files (for ‚Äú<strong>sym</strong>bols‚Äù) have been developed.
Let‚Äôs run RGBLINK to generate a sym file for our ROM:</p>
<p>``console
$ rgblink -n hello-world.sym hello-world.o</p>
<pre><code>
::: warning:‚ÄºÔ∏è

The file names matter!
When looking for a ROM's sym file, emulators take the ROM's file name, strip the extension (here, `.gb`), replace it with `.sym`, and look for a file **in the same directory** with that name.

:::

## Passo

Quando si mette in pausa l'esecuzione, il debugger si concentra automaticamente sull'istruzione che la CPU sta per eseguire, come indicato dalla riga evidenziata in blu.
![Schermata del debugger che mostra che la riga evidenziata corrisponde a PC](../assets/img/pc.png)

::: tip:‚ÑπÔ∏è

The instruction highlighted in blue is always what the CPU is _about to execute_, not what it _just executed_. Keep this in mind.

:::

If we want to watch execution from the beginning, we need to reset the emulator.
Go into the emulator's &quot;File&quot; menu, and select &quot;Reset&quot;, or press &lt;kbd&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Backspace&lt;/kbd&gt;&lt;/kbd&gt;.

La linea blu dovrebbe spostarsi automaticamente all'indirizzo $0100[^boot_addr] e ora siamo pronti a tracciare!
Tutti i comandi per farlo si trovano nel menu &quot;Esegui&quot;.

- &quot;Resume&quot; simply unpauses the emulator.
- &quot;Step Into&quot; and &quot;Step Over&quot; advance the emulator by one instruction.
  They only really differ on the `call` instruction, interrupts, and when encountering a conditional jump, neither of which we are using here, so we will use &quot;Step Into&quot;.
- The other options are not relevant for now.

We will have to &quot;Step Into&quot; a bunch of times, so it's a good idea to use the key shortcut.
If we press &lt;kbd&gt;&lt;kbd&gt;F5&lt;/kbd&gt;&lt;/kbd&gt; once, the `jp EntryPoint` is executed.
And if we press it a few more times, can see the instructions being executed, one by one!

&lt;video controls poster=&quot;../assets/vid/reset_trace.poster.png&quot;&gt;
  &lt;source src=&quot;../assets/vid/reset_trace.webm&quot; type=&quot;video/webm&quot;&gt;
  &lt;source src=&quot;../assets/vid/reset_trace.mp4&quot; type=&quot;video/mp4&quot;&gt;

  &lt;img src=&quot;../assets/vid/reset_trace.gif&quot; alt=&quot;Video demonstration in Emulicious&quot;&gt;
&lt;/video&gt;

Now, you may notice the `WaitVBlank` loop runs a _lot_ of times, but what we are interested in is the `CopyTiles` loop.
We can easily skip over it in several ways; this time, we will use a _breakpoint_.
We will place the breakpoint on the `ld de, Tiles` at `00:0162`; either double-click on that line, or select it and press &lt;kbd&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;B&lt;/kbd&gt;&lt;/kbd&gt;.

![Schermata del debugger che mostra il punto di interruzione](../assets/img/breakpoint.png)

Then you can resume execution by pressing &lt;kbd&gt;&lt;kbd&gt;F8&lt;/kbd&gt;&lt;/kbd&gt;.
Whenever Emulicious is running, and the (emulated) CPU is about to execute an instruction a breakpoint was placed on, it automatically pauses.

![Schermata del debugger che mostra l'esecuzione in pausa sul punto di interruzione](../assets/img/bkpt_pause.png)

La freccia verde e il valore di PC indicano il punto in cui l'esecuzione √® in pausa.

Se tracciamo le tre istruzioni successive, possiamo vedere che i tre argomenti del ciclo `CopyTiles` vengono caricati nei registri.

![Lo stato di alcuni registri all'inizio del ciclo CopyTiles](../assets/img/regs_copytiles.png)

For fun, let's watch the tiles as they're being copied.
For that, obviously, we will use the Memory Editor, and position it at the destination.
As we can see from the image above, that would be $9000!

Click on &quot;Memory&quot; on the bottom window, then &quot;VRAM&quot;, and press &lt;kbd&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;G&lt;/kbd&gt;&lt;/kbd&gt; (for &quot;Goto&quot;).

&lt;video controls poster=&quot;../assets/vid/trace_copy.poster.png&quot;&gt;
  &lt;source src=&quot;../assets/vid/trace_copy.webm&quot; type=&quot;video/webm&quot;&gt;
  &lt;source src=&quot;../assets/vid/trace_copy.mp4&quot; type=&quot;video/mp4&quot;&gt;

  &lt;img src=&quot;../assets/vid/trace_copy.gif&quot; alt=&quot;Video demonstration in Emulicious&quot;&gt;
&lt;/video&gt;

Fantastico, vero?

## E poi?

Congrats, you have just learned how to use a debugger!
We have only scratched the surface, though; we will use more of Emulicious' tools to illustrate the next parts.
Don't worry, from here on, lessons will go with a lot more images‚Äîyou've made it through the hardest part!

---

[^boot_addr]:

Why does execution start at $0100?
That's because it's where the [boot ROM](https://gbdev.io/pandocs/Power_Up_Sequence) hands off control to our game once it's done.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="piastrelle"><a class="header" href="#piastrelle">piastrelle</a></h1>
<div class="box tip decorated">
<div><p>üí≠</p></div>
<div>
<p>Le ‚Äútessere‚Äù venivano chiamate in modo diverso nella documentazione di un tempo.
Di solito venivano chiamate ‚Äúschemi‚Äù o ‚Äúcaratteri‚Äù, e quest‚Äôultima abbreviazione ha dato origine all‚Äôabbreviazione ‚ÄúCHR‚Äù che a volte viene usata per riferirsi alle tessere.</p>
<p>Ad esempio, sul NES, i dati dei tile sono solitamente forniti dalla cartuccia in <a href="http://wiki.nesdev.com/w/index.php/CHR_ROM_vs._CHR_RAM">CHR ROM o CHR RAM</a>.
Il termine ‚ÄúCHR‚Äù non √® tipicamente utilizzato sul Game Boy, anche se gli scambi tra le comunit√† fanno s√¨ che i termini ‚Äútrapelino‚Äù, per cui alcuni si riferiscono all‚Äôarea della VRAM in cui sono memorizzati i tile come ‚ÄúCHR RAM‚Äù o ‚ÄúCHR VRAM‚Äù, ad esempio.</p>
<p>Come per tutti i gerghi di questo tipo, il cui significato pu√≤ dipendere dall‚Äôinterlocutore, per coerenza mi atterr√≤ a ‚Äúpiastrelle‚Äù in tutto il tutorial, essendo ormai lo standard pi√π diffuso nella comunit√† degli sviluppatori di GB.</p>
</div>
</div>
<p>Copiare questi dati alla cieca va benissimo, ma perch√© i dati sono ‚Äúgrafici‚Äù?</p>
<figure>
  <img src="part1/../assets/img/ah_yes_pixels.png" alt="Screenshot of some tile definitions in the code">
  <figcaption><q>Ah, s√¨, i pixel.</q></figcaption>
</figure>
<p>Vediamo un po‚Äô!</p>
<h2 id="mano-utile"><a class="header" href="#mano-utile">Mano utile</a></h2>
<p>Now, figuring out the format with an explanation alone is going to be very confusing; but fortunately, Emulicious got us covered thanks to its <em>Tile Viewer</em>.
You can open it either by selecting ‚ÄúTools‚Äù then ‚ÄúTile Viewer‚Äù, or by clicking on the grid of colored tiles in the debugger‚Äôs toolbar.</p>
<p><img src="part1/../assets/img/vram_viewer.png" alt="Screenshot of the Tile Viewer" /></p>
<p>You can combine the various VRAM viewers by going to ‚ÄúView‚Äù, then ‚ÄúCombine Video Viewers‚Äù.
We will come to the other viewers in due time.
This one shows the tiles present in the Game Boy‚Äôs video memory (or ‚Äú<abbr title="Video RAM">VRAM</abbr>‚Äù).</p>
<div class="box tip decorated">
<div><p>ü§î</p></div>
<div>
<p>Vi invito a sperimentare con il visualizzatore di VRAM, a passare il mouse sulle cose, a spuntare e deselezionare le caselle di controllo, a vedere da soli come stanno le cose. Tutte le domande che vi verranno poste troveranno risposta a tempo debito, non preoccupatevi! E se quello che vedete in seguito non corrisponde alle mie schermate, assicuratevi che le caselle di controllo corrispondano alle mie.</p>
</div>
</div>
<p>Don‚Äôt mind the ‚Äú¬Æ‚Äù icon in the top-left; we did not put it there ourselves, and we will see why it‚Äôs there later.</p>
<h2 id="primer-breve"><a class="header" href="#primer-breve">Primer breve</a></h2>
<p>Potreste aver gi√† sentito parlare di tiles, soprattutto perch√© erano molto popolari nei sistemi a 8 e 16 bit.
Non √® una coincidenza: i tiles sono molto utili.
Invece di memorizzare ogni pixel sullo schermo (144 √ó 160 pixel √ó 2 bit/pixel = 46080 bit = 5760 byte, rispetto agli 8192 byte di VRAM della console), i pixel vengono raggruppati in tile, che vengono poi assemblati in vari modi per produrre l‚Äôimmagine finale.</p>
<p>In particolare, le tessere possono essere riutilizzate molto facilmente e praticamente a costo zero, risparmiando molta memoria!
Inoltre, la manipolazione di intere tessere in una sola volta √® molto pi√π economica rispetto alla manipolazione dei singoli pixel, e questo fa risparmiare tempo di elaborazione.</p>
<p>Il concetto di ‚Äúpiastrella‚Äù √® molto generico, ma sul Game Boy le piastrelle sono <em>sempre</em> di 8 per 8 pixel.
Spesso le tessere hardware vengono raggruppate per essere manipolate come tessere pi√π grandi (spesso 16√ó16); per evitare la confusione, queste vengono chiamate <strong>meta-tessere</strong>.</p>
<h3 id="bpp"><a class="header" href="#bpp">‚Äúbpp‚Äù?</a></h3>
<p>Vi starete chiedendo da dove provenga la cifra di ‚Äú2 bit/pixel‚Äù di cui sopra‚Ä¶
Si tratta della cosiddetta ‚Äúprofondit√† di bit‚Äù.</p>
<p>I colori non sono memorizzati nelle tessere stesse!
Invece, funziona come un libro da colorare: la piastrella stessa contiene <em>indici</em> di 8 x 8, non colori; si d√† all‚Äôhardware una piastrella e un insieme di colori - una <strong>paletta</strong> - e lui li colora!
(Questo √® anche il motivo per cui gli scambi di colore erano molto comuni all‚Äôepoca: si potevano creare variazioni nemiche memorizzando piccole tavolozze invece di grandi grafiche diverse).</p>
<p>In ogni caso, le tavolozze del Game Boy sono grandi 4 colori.<sup class="footnote-reference"><a href="#pal_size">1</a></sup>
Ci√≤ significa che gli indici di tali tavolozze, memorizzati nelle tessere, possono essere rappresentati con soli <em>due bit</em>!
Questo √® chiamato ‚Äú2 bit per pixel‚Äù, noto come ‚Äú2bpp‚Äù.</p>
<p>Con queste premesse, siamo pronti a spiegare come questi byte si trasformano in pixel!</p>
<h2 id="codifica"><a class="header" href="#codifica">Codifica</a></h2>
<p>Come ho spiegato, ogni pixel occupa 2 bit.
Poich√© ci sono 8 bit in un byte, ci si potrebbe aspettare che ogni byte contenga 4 pixel‚Ä¶ e non sarebbe n√© del tutto giusto n√© del tutto sbagliato.
Ogni riga di 8 pixel √® memorizzata in 2 byte, ma nessuno di questi byte contiene le informazioni per 4 pixel.
(Pensate a una banconota da 10 ‚Ç¨ strappata a met√†: nessuna delle due met√† ha valore, ma la banconota intera vale, beh, 10 ‚Ç¨).</p>
<p>Per ogni pixel, il bit meno significativo del suo indice √® memorizzato nel primo byte, mentre il bit pi√π significativo √® memorizzato nel secondo byte.
Poich√© ogni byte √® una raccolta di uno dei bit di ciascun pixel, viene chiamato <strong>bitplane</strong>.</p>
<p>Il pixel pi√π a sinistra √® memorizzato nel bit pi√π a sinistra di entrambi i byte, il pixel alla sua destra nel secondo bit pi√π a sinistra e cos√¨ via.
La prima coppia di byte memorizza la riga superiore, il secondo byte quella inferiore e cos√¨ via.</p>
<p>Ecco una dimostrazione pi√π visiva; si noti che √® per il SNES, ma il suo formato 2BPP √® lo stesso del Game Boy.</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/txkHN6izK2Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Questa codifica pu√≤ sembrare un po‚Äô strana all‚Äôinizio, e pu√≤ esserlo; √® fatta per essere pi√π conveniente per l‚Äôhardware da decodificare, mantenendo la circuiteria semplice e a basso consumo.
Rende possibili anche alcuni trucchi interessanti, come vedremo (molto) pi√π avanti!</p>
<p>Si possono trovare ulteriori informazioni sulla codifica <a href="https://gbdev.io/pandocs/Tile_Data.html">nei Pan Docs</a> e <a href="https://www.huderlem.com/demos/gameboy2bpp.html">nel sito di ShantyTown</a>.</p>
<p>Nella prossima lezione vedremo come si applicano i colori!</p>
<hr />
<div class="footnote-definition" id="pal_size"><sup class="footnote-definition-label">1</sup>
<p>Altre console possono avere profondit√† di bit diverse; ad esempio, lo SNES ha 2bpp, 4bpp e 8bpp a seconda della modalit√† grafica e di alcuni altri parametri.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="palette"><a class="header" href="#palette">Palette</a></h1>
<p>In the previous lesson, I briefly mentioned that colors are applied to tiles via <em>palettes</em>, but we haven‚Äôt talked much about those yet.</p>
<p>Il Game Boy in bianco e nero ha tre tavolozze, una per lo sfondo chiamata <a href="https://gbdev.io/pandocs/Palettes.html#ff47---bgp-bg-palette-data-rw---non-cgb-mode-only"><code>BGP</code></a> (‚ÄúBackGround Palette‚Äù), e due per gli oggetti chiamate <a href="https://gbdev.io/pandocs/Palettes.html#ff48---obp0-object-palette-0-data-rw---non-cgb-mode-only"><code>OBP0</code></a> e <a href="https://gbdev.io/pandocs/Palettes.html#ff48---obp1-object-palette-1-data-rw---non-cgb-mode-only"><code>OBP1</code></a> (‚ÄúOBject Palette 0/1‚Äù).
Se vi state chiedendo cosa siano gli ‚Äúoggetti‚Äù, dovrete aspettare la Parte ‚Ö° per scoprirlo; per ora, concentriamoci sullo sfondo.</p>
<div class="box tip decorated">
<div><p>üåà</p></div>
<div>
<p>Il Game Boy Color ha introdotto, ovviamente, i colori e questo √® stato fatto principalmente rielaborando il modo in cui vengono gestite le tavolozze.
Non parleremo delle caratteristiche del Game Boy Color nella Parte ‚Ö† per semplicit√†, ma lo faremo nelle parti successive.</p>
</div>
</div>
<p>If you chose to combine the video viewers in the previous chapter, the palette viewer should show up on the bottom right of the video viewer.
Otherwise, please select Emulicious‚Äô ‚ÄúTools‚Äù tab, then select <code>Palette Viewer</code>.</p>
<p><img src="part1/../assets/img/pal_viewer.png" alt="Schermata della scheda Palette del visualizzatore VRAM" /></p>
<p>Daremo un‚Äôocchiata alla linea ‚ÄúBGP‚Äù.
Come ho spiegato in precedenza, i riquadri memorizzano gli ‚Äúindici di colore‚Äù per ciascun pixel, che vengono utilizzati per indicizzare la tavolozza.
Il colore numero 0<sup class="footnote-reference"><a href="#numerazione_zero">1</a></sup> √® il pi√π a sinistra in questa riga e il numero 3 √® il pi√π a destra.</p>
<p>Quindi, nel nostro caso, il colore numero 0 √® ‚Äúbianco‚Äù, il numero 1 √® ‚Äúgrigio chiaro‚Äù, il numero 2 √® ‚Äúgrigio scuro‚Äù e il numero 3 ‚Äúnero‚Äù.
Ho messo le virgolette perch√© ‚Äúnero‚Äù non √® il vero nero e ‚Äúbianco‚Äù non √® il vero bianco.
Inoltre, si noti che il Game Boy originale aveva sfumature di verde, mentre lo schermo del successivo Game Boy Pocket produceva sfumature di grigio.
Inoltre, il Game Boy Color √® in grado di colorare automaticamente i giochi che non supportano il Game Boy Color!</p>
<p><img src="part1/../assets/img/hello_world_autocolor.png" alt="Schermata del nostro Hello World, colorato automaticamente dal Game Boy Color" /></p>
<p>Tutto questo per dire che non ci si deve aspettare colori specifici da un gioco per Game Boy<sup class="footnote-reference"><a href="#console_detection">2</a></sup>, ma solo quattro colori pi√π o meno brillanti.</p>
<h2 id="sporcarsi-le-mani"><a class="header" href="#sporcarsi-le-mani">Sporcarsi le mani</a></h2>
<p>Finora in questo tutorial, a parte l‚Äôesecuzione di Hello World, siamo stati piuttosto passivi, osservando il suo svolgimento.
Che ne dite se iniziamo a smuovere un po‚Äô la ROM?</p>
<p>In Emulicious‚Äô debugger, select the ‚ÄúVariables‚Äù tab on the left to show the IO registers.</p>
<p><img src="part1/../assets/img/io_map.png" alt="Schermata della mappa IO" /></p>
<p>While the VRAM viewer offers a visual representation of the palette, the IO map shows the nitty-gritty: how it‚Äôs encoded.
The IO map also lets us modify BGP easily; but to do so, we need to understand <em>how</em> values we write are turned into colors.</p>
<h3 id="codifica-1"><a class="header" href="#codifica-1">Codifica</a></h3>
<p>Fortunatamente, la codifica √® molto semplice.
La spiegher√≤ e allo stesso tempo fornir√≤ un esempio con la tavolozza che abbiamo a portata di mano, $E4.</p>
<p>Take the byte, break its 8 bits into 4 groups of 2.</p>
<pre><code>[BGP] = $E4
$E4 = %11100100 (refresh your memory in the &quot;Binary and hexadecimal&quot; lesson if needed!)
That gets broken down into %11, %10, %01, %00
</code></pre>
<p>Il colore numero 0 √® il ‚Äúgruppo‚Äù pi√π a destra, il colore numero 3 √® quello pi√π a sinistra.
Semplice!
E questo corrisponde a ci√≤ che ci mostra il visualizzatore VRAM: il colore numero 0, il pi√π a destra, √® il pi√π chiaro (%00), fino al colore numero 3, il pi√π a sinistra e il pi√π scuro (%11).</p>
<h3 id="luci-spente"><a class="header" href="#luci-spente">Luci spente</a></h3>
<p>Per divertimento, rendiamo lo schermo completamente nero.
Lo si pu√≤ fare facilmente impostando tutti i colori della tavolozza sul nero (%11).
Questo sarebbe <code>%11 %11 %11 %11 = $FF</code>.</p>
<p>In the ‚ÄúVariables‚Äù tab in the debugger, click on the byte to the right of BGP, erase the ‚ÄúE4‚Äù, type ‚ÄúFF‚Äù, and hit Enter.
BGP immediately updates, turning the screen black!</p>
<figure>
	<img src="part1/../assets/img/pal_viewer_black.png" alt="Screenshot of the palette viewer with the BGP line entirely black">
	<figcaption>Osservate come la linea BGP sia ora completamente nera. Inoltre, avrei potuto mostrare un'immagine della schermata nera, ma sarebbe stato stupido.</figcaption>
</figure>
<p>E se volessimo prendere la tavolozza originale, ma invertirla?
%11 diventerebbe %00, %01 diventerebbe %10, %10 diventerebbe %01, e %00 diventerebbe %11.
Otterremmo cos√¨:</p>
<pre><code>%11_10_01_00
 ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì
%00_01_10_11
</code></pre>
<p>(Non fornir√≤ il valore in esadecimale, ma lo user√≤ come un‚Äôopportunit√† per esercitare le vostre conversioni da bin a esadecimale).</p>
<figure>
	<img src="part1/../assets/img/hello_world_inv.png" alt="Screenshot of the color-inverted Hello World">
	<figcaption>Se avete fatto bene, dovrebbe apparire cos√¨!</figcaption>
</figure>
<p>If you go to the Tile Viewer and change ‚ÄúPalette‚Äù to ‚ÄúGray‚Äù, you will notice that the tile data stays the same regardless of how the palette is modified!
This is an advantage of using palettes: fading the screen in and out is very cheap, just modifying a single byte, instead of having to update every single on-screen pixel.</p>
<p>Avete capito tutto questo?
Allora diamo un‚Äôocchiata all‚Äôultimo pezzo mancante del puzzle nel processo di rendering di Hello World, la <strong>tilemap</strong>!</p>
<hr />
<div class="footnote-definition" id="numbering_zero"><sup class="footnote-definition-label">3</sup></div>
<p>Numbering often starts at 0 when working with computers.
We will understand why later, but for now, please bear with it!</p>
<div class="footnote-definition" id="console_detection"><sup class="footnote-definition-label">2</sup></div>
<p>Well, it is possible to detect these different models and account for them, but this would require taking plenty of corner cases into consideration, so it‚Äôs probably not worth the effort.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tilemap"><a class="header" href="#tilemap">Tilemap</a></h1>
<div class="box tip decorated">
<div><p>üßê</p></div>
<div>
<p>Alcuni li chiamano ‚Äútile map‚Äù, altri ‚Äútilemap‚Äù.
Io user√≤ quest‚Äôultimo di preferenza, ma lo user√≤ anche nel codice (<code>Tilemap</code> e non <code>TileMap</code>), cos√¨ come pi√π avanti quando parleremo di mappe di attributi (‚Äúattrmap‚Äù e <code>Attrmap</code> invece di <code>AttrMap</code>).</p>
</div>
</div>
<p>Ci siamo quasi.
Abbiamo visto come la grafica del Game Boy sia composta da ‚Äúpiastrelle‚Äù 8√ó8 e come il colore venga aggiunto al mix.</p>
<p>Ma non abbiamo ancora visto come queste tessere vengono disposte in un‚Äôimmagine finale!</p>
<p>Tiles are basically a grid of pixels; well, the tilemaps are basically a grid of tiles!
To allow for cheap reuse, tiles aren‚Äôt stored in the tilemap directly; instead, tiles are referred to by an <em>ID</em>, which you can see in Emulicious‚Äô Tile Viewer.</p>
<figure>
  <img src="part1/../assets/img/tile_id.png" alt="Screenshot highlighting where a tile's ID can be seen">
  <figcaption>
    L'ID √® visualizzato in esadecimale senza prefisso, quindi questa √® la tessera numero 10$, ovvero 16.
    Come avrete notato, le tessere sono visualizzate in file da 16, cos√¨ √® pi√π facile individuarle in base all'ID esadecimale.
    Fantastico!
  </figcaption>
</figure>
<p>Naturalmente gli ID delle tessere sono numeri, come tutti i computer.
Gli ID sono memorizzati in byte, quindi ci sono 256 possibili ID di piastrelle.
Tuttavia, il lettore pi√π attento avr√† notato che ci sono 384 tessere in totale<sup class="footnote-reference"><a href="#blocchi_di_tile">1</a></sup>!
In virt√π del <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">principio della piccionaia</a>, ci√≤ significa che alcuni ID si riferiscono a pi√π piastrelle contemporaneamente.</p>
<p>Indeed, Emulicious reports that the first 128 tiles have the same IDs as the last 128.
There exists a mechanism to select whether IDs 0‚Äì127 reference the first or last 128 tiles, but for simplicity‚Äôs sake, we will overlook this for now, so please ignore the first (topmost) 128 tiles for the time being.</p>
<p>Now, please turn your attention to Emulicious‚Äô Tilemap Viewer, pictured below.</p>
<p><img src="part1/../assets/img/tilemap_viewer.png" alt="Schermata del visualizzatore di mappe di piastrelle" /></p>
<div class="box tip">
<p>You may notice that the image shown is larger than what is displayed on-screen.
Only part of the tilemap, outlined by a thicker border in the Tilemap Viewer, is displayed on-screen at a given time.
We will explain this in more detail in Part ‚Ö°.</p>
</div>
<p>Qui potremo vedere la potenza del riutilizzo dei tile in tutta la sua forza.
Per comodit√† e per rinfrescare la memoria, ecco le tessere che il nostro Hello World carica nella VRAM:</p>
<p><img src="part1/../assets/img/hello_world_tiles.png" alt="Vista ingrandita delle tessere caricate nella VRAM" /></p>
<p>Si pu√≤ notare che abbiamo caricato una sola tessera ‚Äúvuota‚Äù ($00, la prima a sinistra in alto), ma pu√≤ essere ripetuta per coprire l‚Äôintero sfondo senza costi aggiuntivi!</p>
<p>La ripetizione pu√≤ essere pi√π sottile: ad esempio, la tessera $01 √® utilizzata per l‚Äôangolo superiore sinistro di H, E, L, L e W (linee rosse in basso)!
Anche la R, la L e la D condividono la loro tessera in alto a sinistra ($2D, linee blu in basso); e cos√¨ via.
√à possibile confermarlo passando il mouse sulle tessere nella scheda BG map, che mostra l‚ÄôID della tessera in quella posizione.</p>
<figure>
  <img src="part1/../assets/img/hello_world_mappings.svg" alt="Diagram of some tile mappings">
  <figcaption>
    Ecco alcuni esempi di riutilizzo delle piastrelle. Non tutto √® disegnato, perch√© diventerebbe un pasticcio.
  </figcaption>
</figure>
<p>Tutto sommato, possiamo dedurre che la visualizzazione della grafica sul Game Boy consiste nel caricare i ‚Äúmodelli‚Äù (le tessere) e nel dire alla console quale tessera visualizzare per ciascuna posizione.</p>
<hr />
<div class="footnote-definition" id="tile_blocks"><sup class="footnote-definition-label">2</sup>
<p>The even more astute (astuter?) reader will have noticed that 384 = 3 √ó 128.
Thus, tiles are often conceptually grouped into three ‚Äúblocks‚Äù of 128 tiles each, which Emulicious shows as separated by thicker horizontal lines.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concludere"><a class="header" href="#concludere">concludere</a></h1>
<p>Congratulazioni!
Avete superato la prima parte di questa esercitazione.
A questo punto, avete una conoscenza di base della console tale da sapere come visualizzare un‚Äôimmagine.
Non sembra molto, ma considerate tutto ci√≤ che avete visto finora: c‚Äô√® molto da fare!</p>
<div class="box tip decorated">
<div><p>ü•≥</p></div>
<div>
<p>Sinceramente, congratulazioni per essere arrivati fino a questo punto: molte persone si sono arrese prima.
Quindi potete darvi una pacca sulla spalla, ve la meritate davvero!
**Se state leggendo tutto questo in un solo tratto, potrebbe essere un buon momento per fare una pausa.
Vi incoraggio a dare un po‚Äô di tempo per assimilare il tutto e magari a tornare alle lezioni su cui avete fatto pi√π fatica.
Forse una seconda lettura pu√≤ aiutarvi.</p>
</div>
</div>
<hr />
<p>E s√¨, si poteva semplicemente lasciare che fosse una libreria a gestire tutto questo.
Tuttavia, i dettagli trapelano sempre alla fine, quindi conoscerli √® utile, anche solo per il debug.</p>
<p>Inoltre, capire cosa succede davvero sotto il cofano vi render√† un programmatore migliore, anche se alla fine non userete ASM.
√à divertente notare che anche i sistemi moderni funzionano in modo simile a quelli pi√π vecchi in punti inaspettati, quindi alcune cose che avete appena imparato si ripeteranno!
Fidatevi di me, tutto ci√≤ che avete imparato e imparerete ne vale la pena! ‚úä</p>
<p>Detto questo, in questo momento potreste avere molte domande.</p>
<ul>
<li>Perch√© spegnere l‚ÄôLCD?</li>
<li>Sappiamo come creare un‚Äôimmagine statica, ma come aggiungere il movimento al mix?</li>
<li>Inoltre, come si ottiene l‚Äôinput dal lettore?</li>
<li>Il codice menziona l‚Äôinterruzione dell‚Äôaudio, ma come faccio a riprodurre alcuni di quei famosi bip e bloop?</li>
<li>Scrivere la grafica in questo modo sembra noioso, non c‚Äô√® altro modo?</li>
<li>Anzi, aspettate, come facciamo a fare un gioco con tutto questo?</li>
</ul>
<p>‚Ä¶ Tutte queste risposte, e altre ancora, nella Parte ‚Ö°! üëÄ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iniziare"><a class="header" href="#iniziare">Iniziare</a></h1>
<p>In questa lezione inizieremo un nuovo progetto da zero.
Creeremo un clone di <a href="https://en.wikipedia.org/wiki/Breakout_%28video_game%29">Breakout</a> / <a href="https://en.wikipedia.org/wiki/Arkanoid">Arkanoid</a>, che chiameremo ‚ÄúUnbricked‚Äù!
(Anche se siete liberi di dargli qualsiasi altro nome, perch√© sar√† il <em>vostro</em> progetto).</p>
<p>Aprire un terminale e creare una nuova directory (<code>mkdir unbricked</code>), quindi entrarvi (<code>cd unbricked</code>), proprio come si √® fatto per <a href="part2/../part1/hello_world.html">‚ÄúHello, world!‚Äù</a>.</p>
<p>Si inizia creando un file chiamato <code>main.asm</code> e si include <code>hardware.inc</code> nel codice.</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;hardware.inc&quot;
</code></pre>
<p>You may be wondering what purpose <code>hardware.inc</code> serves.
Well, the code we write only really affects the CPU, but does not do anything with the rest of the console (not directly, anyway).
To interact with other components (like the graphics system, say), <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">Memory-Mapped <abbr title="Input/Output">I/O</abbr></a> (MMIO) is used: basically, <a href="part2/../part1/memory.html">memory</a> in a certain range (addresses $FF00‚ÄìFF7F) does special things when accessed.</p>
<p>Essendo questi byte di memoria interfacce per l‚Äôhardware, sono chiamati <em>registri hardware</em> (da non confondere con <a href="part2/../part1/registers.html">i registri della CPU</a>).
Ad esempio, il registro ‚Äústato PPU‚Äù si trova all‚Äôindirizzo $FF41.
La lettura di questo indirizzo riporta varie informazioni sul sistema grafico e la scrittura consente di modificare alcuni parametri.
Ma dover ricordare tutti i numeri (<a href="https://gbdev.io/pandocs/Power_Up_Sequence.html#hardware-registers">elenco non esaustivo</a>) sarebbe molto noioso, ed √® qui che entra in gioco <code>hardware.inc</code>!
<code>hardware.inc</code> definisce una costante per ciascuno di questi registri (per esempio, <code>rSTAT</code> per il gi√† citato registro ‚Äústato della PPU‚Äù), pi√π alcune costanti aggiuntive per i valori letti o scritti in questi registri.</p>
<div class="box tip">
<p>Non preoccupatevi se tutto questo vi √® sfuggito di mano: di seguito vedremo un esempio con <code>rLCDC</code> e <code>LCDCF_ON</code>.</p>
<p>A proposito, la <code>r</code> sta per ‚Äúregistro‚Äù e la <code>F</code> in <code>LCDCF</code> sta per ‚Äúflag‚Äù.</p>
</div>
<p>Quindi, fare spazio per l‚Äôintestazione.
<a href="part2/../part1/header.html">Ricordiamo dalla Parte ‚Ö†</a> che l‚Äôintestazione √® il luogo in cui vengono memorizzate alcune informazioni su cui il Game Boy fa affidamento, quindi non bisogna lasciarla fuori per sbaglio.</p>
<pre><code class="language-rgbasm linenos start=3">SECTION &quot;Header&quot;, ROM0[$100]

	jp EntryPoint

	ds $150 - @, 0 ; Make room for the header
</code></pre>
<p>L‚Äôintestazione salta a <code>EntryPoint</code>, quindi scriviamola ora:</p>
<pre><code class="language-rgbasm linenos start=9">EntryPoint:
	; Do not turn the LCD off outside of VBlank
WaitVBlank:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank

	; Turn the LCD off
	ld a, 0
	ld [rLCDC], a
</code></pre>
<p>Le righe successive attendono fino a ‚ÄúVBlank‚Äù, che √® l‚Äôunico momento in cui √® possibile spegnere lo schermo in modo sicuro (farlo nel momento sbagliato potrebbe danneggiare un vero Game Boy, quindi √® molto importante).
Spiegheremo cos‚Äô√® il VBlank e ne parleremo pi√π avanti nel corso dell‚Äôesercitazione.</p>
<p>Spegnere lo schermo √® importante perch√© il caricamento di nuove tessere a schermo acceso √® complicato, come vedremo nella terza parte.</p>
<p>A proposito di tessere, ora ne caricheremo alcune nella VRAM, utilizzando il seguente codice:</p>
<pre><code class="language-rgbasm linenos start=20">	; Copy the tile data
	ld de, Tiles
	ld hl, $9000
	ld bc, TilesEnd - Tiles
CopyTiles:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTiles
</code></pre>
<p>Questo ciclo potrebbe essere <a href="part2/../part1/jumps.html#conditional-jumps">che ricorda la parte ‚Ö†</a>.
Copia a partire da <code>Tiles</code> fino a <code>$9000</code>, che √® la parte di VRAM in cui verr√† memorizzato il nostro <a href="part2/../part1/tiles.html">tiles</a>.
Ricordiamo che <code>$9000</code> √® il luogo in cui si trovano i dati del tile di sfondo $00, e i dati dei tile successivi seguono subito dopo.
Per ottenere il numero di byte da copiare, faremo come nella parte ‚Ö†: usando un‚Äôaltra etichetta alla fine, chiamata <code>TilesEnd</code>, la differenza tra questa (= l‚Äôindirizzo dopo l‚Äôultimo byte dei dati delle tile) e <code>Tiles</code> (= l‚Äôindirizzo del primo byte) sar√† esattamente quella lunghezza.</p>
<p>Detto questo, non abbiamo ancora scritto <code>Tiles</code> n√© i relativi dati.
Ci arriveremo pi√π tardi!</p>
<p>Quasi finito ora - il prossimo, scrivere un altro ciclo, questa volta per copiare <a href="part2/../part1/tilemap.html">la mappa delle piastrelle</a>.</p>
<pre><code class="language-rgbasm linenos start=33">	; Copy the tilemap
	ld de, Tilemap
	ld hl, $9800
	ld bc, TilemapEnd - Tilemap
CopyTilemap:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTilemap
</code></pre>
<p>Si noti che, mentre il corpo di questo ciclo √® esattamente lo stesso di <code>CopyTiles</code>, i 3 valori caricati in <code>de</code>, <code>hl</code> e <code>bc</code> sono diversi.
Questi determinano rispettivamente l‚Äôorigine, la destinazione e la dimensione della copia.</p>
<div class="box tip">
<p class="box-title">‚Äú<a href="https://en.wikipedia.org/wiki/Don&#x27;t_Repeat_Yourself"><abbr title="Don't Repeat Yourself">DRY</abbr></a>‚Äù.</p><p>Se pensate che tutto ci√≤ sia superfluo, non avete torto: vedremo pi√π avanti come scrivere delle vere e proprie <em>funzioni</em> riutilizzabili.
Ma c‚Äô√® molto di pi√π di quello che sembra, quindi inizieremo ad affrontarle molto pi√π avanti.</p>
</div>
<p>Infine, riaccendiamo lo schermo e impostiamo una <a href="part2/../part1/palettes.html">palette di sfondo</a>.
Invece di scrivere il numero non descritto <code>%10000001</code> (o $81 o 129, a seconda dei gusti), usiamo due costanti gentilmente fornite da <code>hardware.inc</code>: <code>LCDCF_ON</code> e <code>LCDCF_BGON</code>.
Quando vengono scritte su <a href="https://gbdev.io/pandocs/LCDC"><code>rLCDC</code></a>, la prima fa s√¨ che la PPU e lo schermo si riaccendano, mentre la seconda permette di disegnare lo sfondo.
(Ci sono altri elementi che potrebbero essere disegnati, ma non li abilitiamo ancora).
La combinazione di queste costanti deve essere fatta usando <code>|</code>, l‚Äôoperatore <em>binario ‚Äúo ‚Äú</em>; vedremo perch√© pi√π avanti.</p>
<pre><code class="language-rgbasm linenos start=46">	; Turn the LCD on
	ld a, LCDCF_ON | LCDCF_BGON
	ld [rLCDC], a

	; During the first (blank) frame, initialize display registers
	ld a, %11100100
	ld [rBGP], a

Done:
	jp Done
</code></pre>
<p>C‚Äô√® un‚Äôultima cosa di cui abbiamo bisogno prima di costruire la ROM: la grafica.
Disegneremo la seguente schermata:</p>
<p><img src="part2/../assets/part2/img/tilemap.png" alt="Layout di unbricked" /></p>
<p>In <code>hello-world.asm', i dati delle mattonelle erano stati scritti a mano in esadecimale; questo per farvi vedere come viene fatta la salsiccia al livello pi√π basso, ma *ragazzo* √® poco pratico da scrivere! Questa volta utilizzeremo un metodo pi√π semplice, che ci permetter√† di scrivere pi√π facilmente ogni riga di pixel. Per ogni riga di pixel, invece di scrivere direttamente [i bitplanes](../part1/tiles.md#encoding), useremo un backtick (`` </code> ``) seguito da 8 caratteri.
Ogni carattere definisce un singolo pixel, intuitivamente da sinistra a destra; deve essere uno tra 0, 1, 2 e 3, che rappresenta l‚Äôindice di colore corrispondente nella <a href="part2/../part1/palettes.html">tavolozza</a>.</p>
<div class="box tip">
<p>Se la selezione dei caratteri non √® di vostro gradimento, potete usare <a href="https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.1#g">l‚Äôopzione <code>-g</code> di RGBASM</a> o <a href="https://rgbds.gbdev.io/docs/v0.5.2/rgbasm.5/#Changing_options_while_assembling"><code>OPT g</code></a> per sceglierne altri.
Per esempio, <code>rgbasm -g '.xXO' (...)</code> o <code>OPT g.xXO</code> scambiano i quattro caratteri rispettivamente con <code>.</code>, <code>x</code>, <code>X</code> e <code>O</code>.</p>
</div>
<p>Ad esempio:</p>
<p>``rgbasm
dw <code>01230123 ; Questo √® equivalente a </code>db $55,$33`</p>
<pre><code>
Avrete notato che stiamo usando `dw` invece di `db`; la differenza tra questi due elementi sar√† spiegata pi√π avanti.
Abbiamo gi√† delle piastrelle per questo progetto, quindi potete copiare [questo file premade](https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tileset.asm) e incollarlo alla fine del vostro codice.

Quindi copiare la mappa delle piastrelle da [questo file] (https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tilemap.asm) e incollarla dopo l'etichetta `TilesEnd`.

√à possibile creare la ROM ora, eseguendo i seguenti comandi nel terminale:

``console
$ rgbasm -L -o main.o main.asm
$ rgblink -o unbricked.gb main.o
$ rgbfix -v -p 0xFF unbricked.gb
</code></pre>
<p>Se si esegue questa operazione nell‚Äôemulatore, si dovrebbe vedere quanto segue:</p>
<p><img src="part2/../assets/part2/img/screenshot.png" alt="Schermata del nostro gioco" /></p>
<p>Quel quadrato bianco sembra essere scomparso!
Forse avete notato questo commento in precedenza, da qualche parte nei dati delle piastrelle:</p>
<pre><code class="language-rgbasm linenos start=135">	dw `22322232
	dw `23232323
	dw `33333333
	; Paste your logo here:

TilesEnd:
</code></pre>
<p>Le tessere del logo sono state lasciate intenzionalmente vuote, in modo che possiate scegliere il vostro.
Potete utilizzare uno dei seguenti loghi gi√† pronti, oppure provare a crearne uno vostro!</p>
<ul>
<li>
<p>Logo RGBDS**</p>
<p><img src="part2/../assets/part2/img/rgbds.png" alt="Il logo RGBDS" /></p>
<p><a href="https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/rgbds.asm">Source</a></p>
</li>
<li>
<p><strong>Duck</strong></p>
<p><img src="part2/../assets/part2/img/duck.png" alt="Un‚Äôanatra in pixel-art" /></p>
<p><a href="https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/duck.asm">Source</a></p>
</li>
<li>
<p><strong>Coda</strong></p>
<p><img src="part2/../assets/part2/img/tail.png" alt="Sagoma di una coda" /></p>
<p><a href="https://github.com/gbdev/gb-asm-tutorial/raw/master/unbricked/getting-started/tail.asm">Source</a></p>
</li>
</ul>
<p>Aggiungete i dati del logo scelto (cliccate su uno dei link ‚ÄúSource‚Äù qui sopra) dopo il commento, create di nuovo il gioco e dovreste vedere il logo scelto in basso a destra!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oggetti"><a class="header" href="#oggetti">Oggetti</a></h1>
<p>Lo sfondo √® molto utile quando l‚Äôintero schermo deve muoversi contemporaneamente, ma non √® l‚Äôideale per tutto.
Ad esempio, il cursore in un menu, i PNG e il giocatore in un RPG, i proiettili in uno shmup o le palline in un clone di <em>Arkanoid</em>‚Ä¶ devono tutti muoversi indipendentemente dallo sfondo.
Fortunatamente, il Game Boy ha una funzione perfetta per queste situazioni!
In questa lezione parleremo di <em>oggetti</em> (talvolta chiamati ‚ÄúOBJ‚Äù).</p>
<div class="box tip">
<p>La descrizione precedente potrebbe avervi fatto pensare al termine ‚Äúsprite‚Äù invece che a ‚Äúoggetto‚Äù.
Il termine ‚Äúsprite‚Äù ha <em>molti</em> significati a seconda del contesto, quindi, per evitare confusione, questo tutorial cerca di usare alternative specifiche, come <em>oggetto</em>, <em>metasprite</em>, <em>attore</em>, ecc.</p>
</div>
<p>Ogni oggetto permette di disegnare una o due piastrelle (rispettivamente 8√ó8 o 8√ó16 pixel) in qualsiasi posizione sullo schermo, a differenza dello sfondo, dove tutte le piastrelle sono disegnate in una griglia.
Pertanto, un oggetto √® composto dalla sua posizione sullo schermo, da un ID tile (come <a href="part2/../part1/tilemap.html">con la tilemap</a>) e da alcune propriet√† extra chiamate ‚Äúattributi‚Äù.
Queste propriet√† extra consentono, ad esempio, di visualizzare la piastrella capovolta.
Ne parleremo pi√π avanti.</p>
<p>Proprio come la tilemap √® memorizzata nella VRAM, gli oggetti vivono in una regione di memoria chiamata OAM, ovvero <strong>Object Attribute Memory</strong>.
Ricordiamo che un oggetto √® composto da:</p>
<ul>
<li>La sua posizione sullo schermo</li>
<li>Un ID tile</li>
<li>Gli ‚Äúattributi‚Äù</li>
</ul>
<p>Questi sono memorizzati in 4 byte: uno per la coordinata Y, uno per la coordinata X, uno per l‚ÄôID della piastrella e uno per gli attributi.
L‚ÄôOAM √® lungo 160 byte e poich√© 160 ‚àï 4 = 40, il Game Boy memorizza un totale di <strong>40</strong> oggetti in qualsiasi momento.</p>
<p>C‚Äô√® per√≤ un problema: i byte delle coordinate Y e X di un oggetto in OAM non memorizzano la sua posizione sullo schermo!
Invece, la posizione X <em>sullo schermo</em> √® la posizione X <em>memorizzata</em> <strong>meno 8</strong>, e la posizione Y <em>sullo schermo</em> √® la posizione Y <em>memorizzata</em> <strong>meno 16</strong>.
Per interrompere la visualizzazione di un oggetto, √® sufficiente metterlo fuori dallo schermo, ad esempio impostando la sua posizione Y a 0.</p>
<div class="box tip">
<p>Questi offset non sono arbitrari!
Si consideri la dimensione massima di un oggetto: 8 x 16 pixel.
Questi offset consentono agli oggetti di essere tagliati dai bordi sinistro e superiore dello schermo.
Il NES, ad esempio, non dispone di tali offset, per cui si noter√† che gli oggetti scompaiono sempre dopo aver toccato il bordo sinistro o superiore dello schermo.</p>
</div>
<p>Scopriamo gli oggetti sperimentandoli!</p>
<p>Innanzitutto, all‚Äôaccensione del Game Boy, l‚ÄôOAM si riempie di valori semicasuali, che possono coprire lo schermo di spazzatura casuale.
Risolviamo questo problema cancellando l‚ÄôOAM prima di attivare gli oggetti per la prima volta.
Aggiungiamo quanto segue subito dopo il ciclo <code>CopyTilemap</code>:</p>
<pre><code class="language-rgbasm">	ld a, 0
	ld b, 160
	ld hl, _OAMRAM
ClearOam:
	ld [hli], a
	dec b
	jp nz, ClearOam
</code></pre>
<p>Questo √® un buon momento per farlo, poich√© proprio come la VRAM, lo schermo deve essere spento per accedere in modo sicuro alla OAM.</p>
<p>Una volta che l‚ÄôOAM √® chiaro, possiamo disegnare un oggetto scrivendo le sue propriet√†.</p>
<pre><code class="language-rgbasm linenos start=67">	ld hl, _OAMRAM
	ld a, 128 + 16
	ld [hli], a
	ld a, 16 + 8
	ld [hli], a
	ld a, 0
	ld [hli], a
	ld [hl], a
</code></pre>
<p>Si ricordi che ogni oggetto in OAM √® composto da 4 byte, nell‚Äôordine Y, X, Tile ID, Attributi.
Quindi, il pixel in alto a sinistra dell‚Äôoggetto si trova a 128 pixel dalla parte superiore dello schermo e a 16 da quella sinistra.
L‚ÄôID tessera e gli attributi sono entrambi impostati a 0.</p>
<p>Come si ricorder√† dalla lezione precedente, stiamo gi√† usando l‚ÄôID 0, che √® l‚Äôinizio della grafica del nostro sfondo.
Tuttavia, per impostazione predefinita, gli oggetti e gli sfondi utilizzano un insieme diverso di piastrelle, almeno per i primi 128 ID.
Le mattonelle con ID 128-255 sono condivise da entrambi, il che √® utile se si ha una mattonella che viene utilizzata sia dallo sfondo che da un oggetto.</p>
<p>If you go to ‚ÄúTools‚Äù, then ‚ÄúTile Viewer‚Äù in Emulicious‚Äô debugger, you should see three distinct sections.</p>
<p><img src="part2/../assets/img/vram_viewer.png" alt="image" /></p>
<p>Poich√© dobbiamo caricarla in un‚Äôarea diversa, useremo l‚Äôindirizzo $8000 e caricheremo una grafica per la paletta del gioco.
Lo faremo subito dopo <code>CopyTilemap</code>:</p>
<pre><code class="language-rgbasm linenos start=46">	; Copy the tile data
	ld de, Paddle
	ld hl, $8000
	ld bc, PaddleEnd - Paddle
CopyPaddle:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyPaddle
</code></pre>
<p>E non dimenticate di aggiungere <code>Paddle</code> alla fine del codice.</p>
<pre><code class="language-rgbasm">Paddle:
	dw `13333331
	dw `30000003
	dw `13333331
	dw `00000000
	dw `00000000
	dw `00000000
	dw `00000000
	dw `00000000
PaddleEnd:
</code></pre>
<p>Infine, abilitiamo gli oggetti e vediamo il risultato.
Gli oggetti devono essere abilitati dal noto registro <code>rLCDC</code>, altrimenti non vengono visualizzati.
(Questo √® il motivo per cui non abbiamo dovuto cancellare l‚ÄôOAM nelle lezioni precedenti).
Dobbiamo anche inizializzare una delle tavolozze degli oggetti, <code>rOBP0</code>.
In realt√† ci sono due tavolozze di oggetti, ma ne useremo solo una.</p>
<pre><code class="language-rgbasm linenos start=76">	; Turn the LCD on
	ld a, LCDCF_ON | LCDCF_BGON | LCDCF_OBJON
	ld [rLCDC], a

	; During the first (blank) frame, initialize display registers
	ld a, %11100100
	ld [rBGP], a
	ld a, %11100100
	ld [rOBP0], a
</code></pre>
<h2 id="movimento"><a class="header" href="#movimento">Movimento</a></h2>
<p>Ora che abbiamo un oggetto sullo schermo, spostiamolo.
In precedenza, il ciclo <code>Done</code> non faceva nulla; rinominiamolo in <code>Main</code> e usiamolo per spostare il nostro oggetto.
Aspetteremo VBlank prima di cambiare OAM, proprio come abbiamo fatto prima di spegnere lo schermo.</p>
<p>``rgbasm,linenos,start=89
Main:
; Attendere finch√© non √® <em>non</em> VBlank
ld a, [rLY]
cp 144
jp nc, Main
WaitVBlank2:
ld a, [rLY]
cp 144
jp c, WaitVBlank2</p>
<pre><code>; Sposta la paletta di un pixel a destra.
ld a, [_OAMRAM + 1]
inc a
ld [_OAMRAM + 1], a
jp Main
</code></pre>
<pre><code>
::: tip:ü§®

In questo caso, si accede all'OAM senza spegnere l'LCD, ma √® comunque sicuro.
Per spiegarne il motivo √® necessaria una spiegazione pi√π approfondita del rendering del Game Boy, quindi per ora ignoriamolo.

:::

Now you should see the paddle moving... very quickly.
Because it moves by a pixel every frame, it's going at a speed of 60 pixels per second!
To slow this down, we'll use a *variable*.

Finora abbiamo lavorato solo con i registri della CPU, ma √® possibile creare anche variabili globali!
Per farlo, creiamo un'altra sezione, ma mettiamola in `WRAM0` invece che in `ROM0`.
A differenza della ROM (&quot;Read-Only Memory&quot;, memoria di sola lettura), la RAM (&quot;Random-Access Memory&quot;, memoria ad accesso casuale) pu√≤ essere scritta; quindi, la WRAM, o Work RAM, √® il luogo in cui possiamo memorizzare le variabili del nostro gioco.

Aggiungete questo in fondo al vostro file:

```rgbasm,linenos,start=358
SECTION &quot;Counter&quot;, WRAM0
wFrameCounter: db
```

Ora useremo la variabile `wFrameCounter` per contare quanti fotogrammi sono passati dall'ultimo spostamento della paletta.
Ogni 10¬∞ fotogramma, sposteremo la racchetta di un pixel, rallentandola a 6 pixel al secondo.
Non dimenticate che all'avvio del Game Boy la RAM si riempie di valori spazzatura, quindi √® necessario inizializzare le variabili prima di utilizzarle.

```rgbasm,linenos,start=86
	ld a, 0
	ld [wFrameCounter], a

Main:
	ld a, [rLY]
	cp 144
	jp nc, Main
WaitVBlank2:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank2

	ld a, [wFrameCounter]
	inc a
	ld [wFrameCounter], a
	cp a, 15 ; Every 15 frames (a quarter of a second), run the following code
	jp nz, Main

	; Reset the frame counter back to 0
	ld a, 0
	ld [wFrameCounter], a

	; Move the paddle one pixel to the right.
	ld a, [_OAMRAM + 1]
	inc a
	ld [_OAMRAM + 1], a
	jp Main
```

Bene!
Il prossimo passo √® prendere il controllo della paletta.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funzioni"><a class="header" href="#funzioni">Funzioni</a></h1>
<p>Finora abbiamo scritto un solo ‚Äúflusso‚Äù di codice, ma possiamo gi√† individuare alcuni frammenti che sembrano ridondanti.
Usiamo le <strong>funzioni</strong> per ‚Äúsfoltire‚Äù il codice!</p>
<p>Per esempio, in tre punti stiamo copiando pezzi di memoria.
Scriviamo una funzione sotto la <code>jp Main</code> e chiamiamola <code>Memcpy</code>, come <a href="https://man7.org/linux/man-pages/man3/memcpy.3.html">l‚Äôanaloga funzione C</a>:</p>
<pre><code class="language-rgbasm linenos start=93">; Copy bytes from one area to another.
; @param de: Source
; @param hl: Destination
; @param bc: Length
Memcopy:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, Memcopy
	ret
</code></pre>
<p>La nuova istruzione <code>ret' dovrebbe catturare immediatamente l'attenzione. √à, senza sorpresa, quella che fa s√¨ che l'esecuzione *ritorni* al punto in cui la funzione √® stata *chiamata*. √à importante notare che molti linguaggi prevedono una &quot;fine&quot; precisa per una funzione: in C o Rust, √® la parentesi graffa di chiusura </code>}<code>; in Pascal o Lua, la parola chiave </code>end<code>, e cos√¨ via; la funzione ritorna implicitamente quando l'esecuzione raggiunge la sua fine. Tuttavia, **non √® cos√¨ in assembly**, quindi bisogna ricordarsi di aggiungere un'istruzione </code>ret` alla fine della funzione per ritornare da essa!
Altrimenti, i risultati sono imprevedibili.</p>
<p>Notate il commento sopra la funzione, che spiega quali registri prende in ingresso.
Questo commento √® importante per sapere come interfacciarsi con la funzione; l‚Äôassembly non ha parametri formali, quindi i commenti che li spiegano sono ancora pi√π importanti che in altri linguaggi.
Ne vedremo altri man mano che procediamo.</p>
<p>Ci sono tre punti nel codice di inizializzazione in cui possiamo usare la funzione <code>Memcpy</code>.
Trovate ognuno di questi cicli di copia e sostituiteli con una chiamata a <code>Memcpy</code>; per questo, utilizziamo l‚Äôistruzione <code>call</code>.
I registri servono come parametri alla funzione, quindi li lasceremo cos√¨ come sono.</p>
<div class="table-wrapper"><table><thead><tr><th>Prima di</th><th>Dopo</th></tr></thead><tbody><tr><td>
<pre><code class="language-rgbasm linenos start=20">	; Copy the tile data
	ld de, Tiles
	ld hl, $9000
	ld bc, TilesEnd - Tiles
CopyTiles:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTiles
</code></pre>
</td><td>
<pre><code class="language-rgbasm linenos start=20">	; Copy the tile data
	ld de, Tiles
	ld hl, $9000
	ld bc, TilesEnd - Tiles
	call Memcopy
</code></pre>
</td></tr><tr><td>
<pre><code class="language-rgbasm linenos start=33">	; Copy the tilemap
	ld de, Tilemap
	ld hl, $9800
	ld bc, TilemapEnd - Tilemap
CopyTilemap:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyTilemap
</code></pre>
</td><td>
<pre><code class="language-rgbasm linenos start=26">	; Copy the tilemap
	ld de, Tilemap
	ld hl, $9800
	ld bc, TilemapEnd - Tilemap
	call Memcopy
</code></pre>
</td></tr><tr><td>
<pre><code class="language-rgbasm linenos start=46">	; Copy the tile data
	ld de, Paddle
	ld hl, $8000
	ld bc, PaddleEnd - Paddle
CopyPaddle:
	ld a, [de]
	ld [hli], a
	inc de
	dec bc
	ld a, b
	or a, c
	jp nz, CopyPaddle
</code></pre>
</td><td>
<pre><code class="language-rgbasm linenos start=32">	; Copy the tile data
	ld de, Paddle
	ld hl, $8000
	ld bc, PaddleEnd - Paddle
	call Memcopy
</code></pre>
</td></tr></tbody></table></div>
<p>Nel prossimo capitolo, scriveremo un‚Äôaltra funzione, questa volta per leggere gli input del giocatore.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ingresso"><a class="header" href="#ingresso">Ingresso</a></h1>
<p>Abbiamo le fondamenta di un gioco, ma manca ancora l‚Äôinput del giocatore.
Un gioco che si gioca da solo non √® molto divertente, quindi cerchiamo di risolvere questo problema.</p>
<p>Incollare questo codice sotto il ciclo <code>Main</code>.
Come <code>Memcpy</code>, questa √® una funzione che pu√≤ essere riutilizzata da diversi punti, utilizzando l‚Äôistruzione <code>call</code>.</p>
<pre><code class="language-rgbasm linenos start=110">UpdateKeys:
  ; Poll half the controller
  ld a, P1F_GET_BTN
  call .onenibble
  ld b, a ; B7-4 = 1; B3-0 = unpressed buttons

  ; Poll the other half
  ld a, P1F_GET_DPAD
  call .onenibble
  swap a ; A3-0 = unpressed directions; A7-4 = 1
  xor a, b ; A = pressed buttons + directions
  ld b, a ; B = pressed buttons + directions

  ; And release the controller
  ld a, P1F_GET_NONE
  ldh [rP1], a

  ; Combine with previous wCurKeys to make wNewKeys
  ld a, [wCurKeys]
  xor a, b ; A = keys that changed state
  and a, b ; A = keys that changed to pressed
  ld [wNewKeys], a
  ld a, b
  ld [wCurKeys], a
  ret

.onenibble
  ldh [rP1], a ; switch the key matrix
  call .knownret ; burn 10 cycles calling a known ret
  ldh a, [rP1] ; ignore value while waiting for the key matrix to settle
  ldh a, [rP1]
  ldh a, [rP1] ; this read counts
  or a, $F0 ; A7-4 = 1; A3-0 = unpressed keys
.knownret
  ret
</code></pre>
<p>Sfortunatamente, la lettura degli input sul Game Boy √® piuttosto complessa (come potete vedere!) e sarebbe piuttosto difficile spiegare cosa fa questa funzione in questo momento.
Vi chiedo quindi di fare un‚Äôeccezione e di fidarvi del fatto che questa funzione legge l‚Äôinput.
Va bene? Bene!</p>
<p>Ora che sappiamo come usare le funzioni, chiamiamo la funzione <code>UpdateKeys</code> nel nostro ciclo principale per leggere l‚Äôinput dell‚Äôutente.
La funzione <code>UpdateKeys</code> scrive i pulsanti tenuti in una posizione in memoria che abbiamo chiamato <code>wCurKeys</code>, da cui possiamo leggere dopo il ritorno della funzione.
Per questo motivo, √® sufficiente chiamare <code>UpdateKeys</code> una sola volta per ogni fotogramma.</p>
<p>Questo √® importante, perch√© non solo √® pi√π veloce ricaricare gli input che abbiamo gi√† elaborato, ma significa anche che agiremo sempre sugli stessi input, anche se il giocatore preme o rilascia un pulsante a met√† fotogramma.</p>
<p>Per prima cosa, mettiamo da parte un po‚Äô di spazio per le due variabili che <code>UpdateKeys</code> utilizzer√†; incollate questo alla fine del file <code>main.asm</code>:</p>
<pre><code class="language-rgbasm linenos start=407">SECTION &quot;Input Variables&quot;, WRAM0
wCurKeys: db
wNewKeys: db
</code></pre>
<p>Ogni variabile deve risiedere nella RAM e non nella ROM, perch√© la ROM √® ‚ÄúRead-Only‚Äù (quindi non pu√≤ essere modificata).
Inoltre, ogni variabile deve essere grande solo un byte, quindi si usa <code>db</code> (‚ÄúDefine Byte‚Äù) per riservare un byte di RAM a ciascuna.</p>
<p>Utilizzeremo l‚Äôopcode <code>and</code>, che pu√≤ essere utilizzato per impostare il flag di zero (<code>z</code>) sul valore del bit.
Possiamo usare questo insieme alle costanti <code>PADF</code> in hardware.inc per leggere un particolare tasto.</p>
<pre><code class="language-rgbasm linenos start=68">Main:
	ld a, [rLY]
	cp 144
	jp nc, Main
WaitVBlank2:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank2

	; Check the current keys every frame and move left or right.
	call UpdateKeys

	; First, check if the left button is pressed.
CheckLeft:
	ld a, [wCurKeys]
	and a, PADF_LEFT
	jp z, CheckRight
Left:
	; Move the paddle one pixel to the left.
	ld a, [_OAMRAM + 1]
	dec a
	; If we've already hit the edge of the playfield, don't move.
	cp a, 15
	jp z, Main
	ld [_OAMRAM + 1], a
	jp Main

; Then check the right button.
CheckRight:
	ld a, [wCurKeys]
	and a, PADF_RIGHT
	jp z, Main
Right:
	; Move the paddle one pixel to the right.
	ld a, [_OAMRAM + 1]
	inc a
	; If we've already hit the edge of the playfield, don't move.
	cp a, 105
	jp z, Main
	ld [_OAMRAM + 1], a
	jp Main
</code></pre>
<p>Ora, se compilate il progetto, dovreste essere in grado di muovere la racchetta a destra e a sinistra usando il d-pad!!!
Urr√†, abbiamo l‚Äôinizio di un gioco!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collisione"><a class="header" href="#collisione">Collisione</a></h1>
<p>Potersi muovere √® fantastico, ma c‚Äô√® ancora un oggetto di cui abbiamo bisogno per questo gioco: una palla!
Come per la racchetta, il primo passo √® creare un riquadro per la palla e caricarlo nella VRAM.</p>
<h2 id="grafica"><a class="header" href="#grafica">Grafica</a></h2>
<p>Add this to the bottom of your file along with the other graphics:</p>
<pre><code class="language-rgbasm linenos start=570">Ball:
	dw `00033000
	dw `00322300
	dw `03222230
	dw `03222230
	dw `00322300
	dw `00033000
	dw `00000000
	dw `00000000
BallEnd:
</code></pre>
<p>Now copy it to VRAM somewhere in your initialization code, e.g. after copying the paddle‚Äôs tile.</p>
<pre><code class="language-rgbasm linenos start=38">	; Copy the ball tile
	ld de, Ball
	ld hl, $8010
	ld bc, BallEnd - Ball
	call Memcopy
</code></pre>
<p>In addition, we need to initialize an entry in OAM, following the code that initializes the paddle.</p>
<pre><code class="language-rgbasm linenos start=52">	; Initialize the paddle sprite in OAM
	ld hl, _OAMRAM
	ld a, 128 + 16
	ld [hli], a
	ld a, 16 + 8
	ld [hli], a
	ld a, 0
	ld [hli], a
	ld [hli], a
	; Now initialize the ball sprite
	ld a, 100 + 16
	ld [hli], a
	ld a, 32 + 8
	ld [hli], a
	ld a, 1
	ld [hli], a
	ld a, 0
	ld [hli], a
</code></pre>
<p>As the ball bounces around the screen its momentum will change, sending it in different directions.
Let‚Äôs create two new variables to track the ball‚Äôs momentum in each axis: <code>wBallMomentumX</code> and <code>wBallMomentumY</code>.</p>
<pre><code class="language-rgbasm linenos start=581">SECTION &quot;Counter&quot;, WRAM0
wFrameCounter: db

SECTION &quot;Input Variables&quot;, WRAM0
wCurKeys: db
wNewKeys: db

SECTION &quot;Ball Data&quot;, WRAM0
wBallMomentumX: db
wBallMomentumY: db
</code></pre>
<p>We will need to initialize these before entering the game loop, so let‚Äôs do so right after we write the ball to OAM.
By setting the X momentum to 1, and the Y momentum to -1, the ball will start out by going up and to the right.</p>
<pre><code class="language-rgbasm linenos start=61">	; Now initialize the ball sprite
	ld a, 100 + 16
	ld [hli], a
	ld a, 32 + 8
	ld [hli], a
	ld a, 1
	ld [hli], a
	ld a, 0
	ld [hli], a

	; The ball starts out going up and to the right
	ld a, 1
	ld [wBallMomentumX], a
	ld a, -1
	ld [wBallMomentumY], a
</code></pre>
<h2 id="lavoro-di-preparazione"><a class="header" href="#lavoro-di-preparazione">Lavoro di preparazione</a></h2>
<p>Now for the fun part!
Add a bit of code at the beginning of your main loop that adds the momentum to the OAM positions.
Notice that since this is the second OAM entry, we use <code>+ 4</code> for Y and <code>+ 5</code> for X.
This can get pretty confusing, but luckily we only have two objects to keep track of.
In the future, we‚Äôll go over a much easier way to use OAM.</p>
<pre><code class="language-rgbasm linenos start=90">Main:
	ld a, [rLY]
	cp 144
	jp nc, Main
WaitVBlank2:
	ld a, [rLY]
	cp 144
	jp c, WaitVBlank2

	; Add the ball's momentum to its position in OAM.
	ld a, [wBallMomentumX]
	ld b, a
	ld a, [_OAMRAM + 5]
	add a, b
	ld [_OAMRAM + 5], a

	ld a, [wBallMomentumY]
	ld b, a
	ld a, [_OAMRAM + 4]
	add a, b
	ld [_OAMRAM + 4], a
</code></pre>
<p>Si consiglia di compilare nuovamente il gioco per vedere cosa fa.
Se lo fate, dovreste vedere la palla muoversi, ma passer√† attraverso i muri e poi voler√† fuori dallo schermo.</p>
<p>Per risolvere questo problema, dobbiamo aggiungere il rilevamento delle collisioni, in modo che la palla possa rimbalzare.
Dovremo ripetere il controllo delle collisioni un paio di volte, quindi utilizzeremo due funzioni per farlo.</p>
<div class="box tip">
<p>Non perdetevi nei dettagli di questa funzione, perch√© utilizza alcune tecniche e istruzioni che non abbiamo ancora discusso.
L‚Äôidea di base √® che converte la posizione dello sprite in una posizione sulla mappa delle piastrelle.
In questo modo, possiamo controllare quale piastrella sta toccando la nostra palla, in modo da sapere quando rimbalzare!</p>
</div>
<pre><code class="language-rgbasm linenos start=226">; Convert a pixel position to a tilemap address
; hl = $9800 + X + Y * 32
; @param b: X
; @param c: Y
; @return hl: tile address
GetTileByPixel:
	; First, we need to divide by 8 to convert a pixel position to a tile position.
	; After this we want to multiply the Y position by 32.
	; These operations effectively cancel out so we only need to mask the Y value.
	ld a, c
	and a, %11111000
	ld l, a
	ld h, 0
	; Now we have the position * 8 in hl
	add hl, hl ; position * 16
	add hl, hl ; position * 32
	; Convert the X position to an offset.
	ld a, b
	srl a ; a / 2
	srl a ; a / 4
	srl a ; a / 8
	; Add the two offsets together.
	add a, l
	ld l, a
	adc a, h
	sub a, l
	ld h, a
	; Add the offset to the tilemap's base address, and we are done!
	ld bc, $9800
	add hl, bc
	ret
</code></pre>
<p>The next function is called <code>IsWallTile</code>, and it‚Äôs going to contain a list of tiles which the ball can bounce off of.</p>
<pre><code class="language-rgbasm linenos start=258">; @param a: tile ID
; @return z: set if a is a wall.
IsWallTile:
	cp a, $00
	ret z
	cp a, $01
	ret z
	cp a, $02
	ret z
	cp a, $04
	ret z
	cp a, $05
	ret z
	cp a, $06
	ret z
	cp a, $07
	ret
</code></pre>
<p>Questa funzione pu√≤ sembrare un po‚Äô strana all‚Äôinizio.
Invece di restituire il risultato in un <em>registro</em>, come <code>a</code>, lo restituisce in <a href="part2/../part1/operations.html#flags">un <em>flag</em></a>: <code>Z</code>!
Se in qualsiasi punto una piastrella corrisponde, la funzione ha trovato un muro ed esce con <code>Z</code> impostato.
Se l‚ÄôID della piastrella di destinazione (in <code>a</code>) corrisponde a uno degli ID delle piastrelle del muro, il corrispondente <code>cp</code> lascer√† <code>Z</code> impostato; in tal caso, si ritorna immediatamente (tramite <code>ret z</code>), con <code>Z</code> impostato.
Ma se, dopo aver effettuato l‚Äôultimo confronto, <code>Z</code> non viene ancora impostato, sapremo che non abbiamo colpito un muro e non abbiamo bisogno di rimbalzare.</p>
<h2 id="mettere-insieme"><a class="header" href="#mettere-insieme">Mettere insieme</a></h2>
<p>Time to use these new functions to add collision detection!
Add the following after the code that updates the ball‚Äôs position:</p>
<pre><code class="language-rgbasm linenos start=112">BounceOnTop:
	; Remember to offset the OAM position!
	; (8, 16) in OAM coordinates is (0, 0) on the screen.
	ld a, [_OAMRAM + 4]
	sub a, 16 + 1
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8
	ld b, a
	call GetTileByPixel ; Returns tile address in hl
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnRight
	ld a, 1
	ld [wBallMomentumY], a
</code></pre>
<p>Vedrete che quando carichiamo le posizioni dello sprite, le sottraiamo prima di chiamare <code>GetTileByPixel</code>.
Forse ricorderete dall‚Äôultimo capitolo che le posizioni OAM sono leggermente sfalsate; cio√®, (0, 0) in OAM √® in realt√† completamente fuori dallo schermo.
Queste istruzioni <code>sub</code> annullano questo offset.</p>
<p>Tuttavia, c‚Äô√® dell‚Äôaltro: avrete notato che abbiamo sottratto un pixel in pi√π dalla posizione Y. Questo perch√© (come suggerisce l‚Äôetichetta) questo codice controlla la presenza di una piastrella sopra la palla.
Questo perch√© (come suggerisce l‚Äôetichetta), il codice controlla la presenza di una piastrella sopra la palla.
In realt√† abbiamo bisogno di controllare <em>tutti e quattro</em> i lati della palla, in modo da sapere come cambiare la quantit√† di moto a seconda del lato che si √® scontrato, quindi‚Ä¶ aggiungiamo il resto!</p>
<pre><code class="language-rgbasm linenos start=128">BounceOnRight:
	ld a, [_OAMRAM + 4]
	sub a, 16
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8 - 1
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnLeft
	ld a, -1
	ld [wBallMomentumX], a

BounceOnLeft:
	ld a, [_OAMRAM + 4]
	sub a, 16
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8 + 1
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnBottom
	ld a, 1
	ld [wBallMomentumX], a

BounceOnBottom:
	ld a, [_OAMRAM + 4]
	sub a, 16 - 1
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceDone
	ld a, -1
	ld [wBallMomentumY], a
BounceDone:
</code></pre>
<p>Era molto, ma ora la palla rimbalza sullo schermo!
C‚Äô√® solo un‚Äôultima cosa da fare prima della fine di questo capitolo: la collisione tra palla e paddle.</p>
<h2 id="rimbalzo-della-pagaia"><a class="header" href="#rimbalzo-della-pagaia">Rimbalzo della pagaia</a></h2>
<p>A differenza di quanto accade con la mappa di piastrelle, qui non √® necessario effettuare conversioni di posizione, ma solo confronti diretti.
Tuttavia, per questi ultimi, avremo bisogno <a href="part2/../part1/operations.html#flags">del flag <em>carry</em></a>.
Il flag di riporto √® indicato con <code>C</code>, come il flag di zero √® indicato con <code>Z</code>, ma non bisogna confonderlo con il registro <code>c</code>!</p>
<div class="box tip">
<p class="box-title">Un ripasso sui confronti</p><p>Proprio come <code>Z</code>, √® possibile utilizzare il flag di riporto per saltare in modo condizionato.
Tuttavia, mentre <code>Z</code> viene utilizzato per verificare se due numeri sono uguali, <code>C</code> pu√≤ essere utilizzato per verificare se un numero √® maggiore o minore di un altro.
Per esempio, <code>cp a, b</code> imposta <code>C</code> se <code>a &lt; b</code>, and clears it if <code>a &gt;= b</code>.
(Se si vuole verificare <code>a &lt;= b</code> or <code>a &gt; b</code>, si possono usare <code>Z</code> e <code>C</code> in tandem con due istruzioni <code>jp</code>).</p>
</div>
<p>Armed with this knowledge, let‚Äôs work through the paddle bounce code:</p>
<pre><code class="language-rgbasm linenos start=171">	; First, check if the ball is low enough to bounce off the paddle.
	ld a, [_OAMRAM]
	ld b, a
	ld a, [_OAMRAM + 4]
	cp a, b
	jp nz, PaddleBounceDone ; If the ball isn't at the same Y position as the paddle, it can't bounce.
	; Now let's compare the X positions of the objects to see if they're touching.
	ld a, [_OAMRAM + 5] ; Ball's X position.
	ld b, a
	ld a, [_OAMRAM + 1] ; Paddle's X position.
	sub a, 8
	cp a, b
	jp c, PaddleBounceDone
	add a, 8 + 16 ; 8 to undo, 16 as the width.
	cp a, b
	jp nc, PaddleBounceDone

	ld a, -1
	ld [wBallMomentumY], a

PaddleBounceDone:
</code></pre>
<p>Il controllo della posizione Y √® semplice, poich√© la nostra racchetta √® piatta.
Tuttavia, la posizione X ha due controlli che ampliano l‚Äôarea in cui la palla pu√≤ rimbalzare.
Innanzitutto aggiungiamo 16 alla posizione della pallina; se la pallina si trova a pi√π di 16 pixel a destra della racchetta, non dovrebbe rimbalzare.
Poi annulliamo questa operazione sottraendo 16 e, gi√† che ci siamo, sottraiamo altri 8 pixel; se la palla si trova a pi√π di 8 pixel a sinistra della racchetta, non dovrebbe rimbalzare.</p>
<svg viewBox="-10 -10 860 520">
	<style>
		text { text-anchor: middle; fill: var(--fg); font-size: 20px; }
		.left { text-anchor: start; }
		.right { text-anchor: end; }
		.grid { stroke: var(--fg); opacity: 0.7; }
		.ball { stroke: verde acqua; }
		.paddle { stroke: orange; }
		.excl { stroke: red; } text.excl { stroke: initial; fill: red; font-family: "Source Code Pro", Consolas, "Ubuntu Mono", Menlo, "DejaVu Sans Mono", monospace, monospace !important; }
		/* Sovrapposizioni */
		rect, polyline { opacity: 0.5; stroke-width: 3; }
		/* Freccia */
		poligono { stroke: inherit; fill: var(--bg); }
		uso + linea { stroke-dasharray: 0 32 999; larghezza tratto: 2; }
	</style>
	<defs>
		<polygon id="arrow-head" points="0,0 -40,-16 -32,0 -40,16" stroke="context-stroke"/>
		<pattern id="ball-hatched" viewBox="0 0 4 4" width="8" height="8" patternUnits="userSpaceOnUse">
			<line x1="5" y1="-1" x2="-1" y2="5" class="ball"/>
			<line x1="5" y1="3" x2="3" y2="5" class="ball"/>
			<line x1="1" y1="-1" x2="-1" y2="1" class="ball"/>
		</pattern>
		<pattern id="paddle-hatched" viewBox="0 0 4 4" width="8" height="8" patternUnits="userSpaceOnUse">
			<line x1="5" y1="-1" x2="-1" y2="5" class="paddle"/>
			<line x1="5" y1="3" x2="3" y2="5" class="paddle"/>
			<line x1="1" y1="-1" x2="-1" y2="1" class="paddle"/>
		</pattern>
		<pattern id="excl-hatched" viewBox="0 0 4 4" width="8" height="8" patternUnits="userSpaceOnUse">
			<line x1="5" y1="-1" x2="-1" y2="5" class="excl"/>
			<line x1="5" y1="3" x2="3" y2="5" class="excl"/>
			<line x1="1" y1="-1" x2="-1" y2="1" class="excl"/>
		</pattern>
	</defs>
	<image x="128" y="0" width="256" height="256" href="../assets/part2/img/ball.png"/>
	<rect x="128" y="0" width="32" height="32" fill="url(#ball-hatched)"/>
	<image x="288" y="256" width="256" height="256" href="../assets/part2/img/paddle.png"/>
	<rect x="288" y="256" width="32" height="32" fill="url(#paddle-hatched)"/>
	<line class="grid" x1="-10" y1="0" x2="850" y2="0"/>
	<line class="grid" x1="-10" y1="32" x2="850" y2="32"/>
	<line class="grid" x1="-10" y1="64" x2="850" y2="64"/>
	<line class="grid" x1="-10" y1="96" x2="850" y2="96"/>
	<line class="grid" x1="-10" y1="128" x2="850" y2="128"/>
	<line class="grid" x1="-10" y1="160" x2="850" y2="160"/>
	<line class="grid" x1="-10" y1="192" x2="850" y2="192"/>
	<line class="grid" x1="-10" y1="224" x2="850" y2="224"/>
	<line class="grid" x1="-10" y1="256" x2="850" y2="256"/>
	<line class="grid" x1="-10" y1="288" x2="850" y2="288"/>
	<line class="grid" x1="-10" y1="320" x2="850" y2="320"/>
	<line class="grid" x1="-10" y1="352" x2="850" y2="352"/>
	<line class="grid" x1="0" y1="-20" x2="0" y2="351"/>
	<line class="grid" x1="32" y1="-20" x2="32" y2="351"/>
	<line class="grid" x1="64" y1="-20" x2="64" y2="351"/>
	<line class="grid" x1="96" y1="-20" x2="96" y2="351"/>
	<line class="grid" x1="128" y1="-20" x2="128" y2="351"/>
	<line class="grid" x1="160" y1="-20" x2="160" y2="351"/>
	<line class="grid" x1="192" y1="-20" x2="192" y2="351"/>
	<line class="grid" x1="224" y1="-20" x2="224" y2="351"/>
	<line class="grid" x1="256" y1="-20" x2="256" y2="351"/>
	<line class="grid" x1="288" y1="-20" x2="288" y2="351"/>
	<line class="grid" x1="320" y1="-20" x2="320" y2="351"/>
	<line class="grid" x1="352" y1="-20" x2="352" y2="351"/>
	<line class="grid" x1="384" y1="-20" x2="384" y2="351"/>
	<line class="grid" x1="416" y1="-20" x2="416" y2="351"/>
	<line class="grid" x1="448" y1="-20" x2="448" y2="351"/>
	<line class="grid" x1="480" y1="-20" x2="480" y2="351"/>
	<line class="grid" x1="512" y1="-20" x2="512" y2="351"/>
	<line class="grid" x1="544" y1="-20" x2="544" y2="351"/>
	<line class="grid" x1="576" y1="-20" x2="576" y2="351"/>
	<line class="grid" x1="608" y1="-20" x2="608" y2="351"/>
	<line class="grid" x1="640" y1="-20" x2="640" y2="351"/>
	<line class="grid" x1="672" y1="-20" x2="672" y2="351"/>
	<line class="grid" x1="704" y1="-20" x2="704" y2="351"/>
	<line class="grid" x1="736" y1="-20" x2="736" y2="351"/>
	<line class="grid" x1="768" y1="-20" x2="768" y2="351"/>
	<line class="grid" x1="800" y1="-20" x2="800" y2="351"/>
	<line class="grid" x1="832" y1="-20" x2="832" y2="351"/>
	<rect x="128" y="0" width="256" height="256" class="ball" style="fill: none;"/>
	<polyline points="288,352 288,256 544,256 544,352" class="paddle" style="fill: none;"/>
	<rect x="-15" y="-15" width="47" height="440" class="excl" fill="url(#excl-hatched)"/>
	<text x="40" y="430" class="excl left">jp c, DoNotBounce</text>
	<rect x="800" y="-15" width="52" height="510" class="excl" fill="url(#excl-hatched)"/>
	<text x="790" y="500" class="excl right">jp nc, DoNotBounce</text>
	<use href="#arrow-head" x="48" y="380" transform="rotate(-180,48,380)" class="paddle"/><line x1="48" y1="380" x2="304" y2="380" class="paddle"/>
	<text x="176" y="400">- 8</text>
	<use href="#arrow-head" x="304" y="450" class="paddle"/><line x1="304" y1="450" x2="48" y2="450" class="paddle"/>
	<use href="#arrow-head" x="816" y="450" class="paddle"/><line x1="816" y1="450" x2="304" y2="450" class="paddle"/>
	<text x="432" y="470">+ 8 + 16</text>
</svg>
<div class="box tip">
<p class="box-title">Larghezza della paletta</p><p>Ci si potrebbe chiedere perch√© abbiamo controllato 16 pixel a destra ma solo 8 pixel a sinistra.
Ricordate che le posizioni OAM rappresentano l‚Äôangolo superiore<em>sinistro</em> di uno sprite, quindi il centro della nostra paletta √® in realt√† 4 pixel a destra della posizione in OAM.
Se si considera questo, in realt√† stiamo controllando 12 pixel su entrambi i lati dal centro della paletta.</p>
<p>12 pixel possono sembrare molti, ma danno un po‚Äô di tolleranza al giocatore nel caso in cui il suo posizionamento sia sbagliato.
Se si preferisce rendere il tutto pi√π facile o pi√π difficile, √® possibile regolare i valori!</p>
</div>
<h2 id="bonus-modifica-dellaltezza-di-rimbalzo"><a class="header" href="#bonus-modifica-dellaltezza-di-rimbalzo">BONUS: modifica dell‚Äôaltezza di rimbalzo</a></h2>
<p>Si pu√≤ notare che la pallina sembra ‚Äúaffondare‚Äù un po‚Äô nella paletta prima di rimbalzare. Questo perch√© la pallina rimbalza quando la sua riga superiore di pixel si allinea con la riga superiore della paletta (si veda l‚Äôimmagine sopra). Se volete, provate a regolare questo aspetto in modo che la pallina rimbalzi quando la sua fila di pixel inferiore tocca quella superiore della paletta.</p>
<p>Suggerimento: √® possibile farlo con una sola istruzione!</p>
<details><summary>Risposta:</summary>
<pre><code class="language-diff linenos start=171">	ld a, [_OAMRAM]
	ld b, a
	ld a, [_OAMRAM + 4]
+ sub a, 6
	cp a, b
</code></pre>
<p>In alternativa, si pu√≤ aggiungere <code>add a, 6</code> subito dopo <code>ld a, [_OAMRAM]</code>.</p>
<p>In entrambi i casi, provate a giocare con il valore <code>6</code>; vedete cosa vi sembra giusto!</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bricks"><a class="header" href="#bricks">Bricks</a></h1>
<p>Up until this point our ball hasn‚Äôt done anything but bounce around, but now we‚Äôre going to make it destroy the bricks.</p>
<p>Before we start, let‚Äôs go over a new concept: constants.
We‚Äôve already used some constants, like <code>rLCDC</code> from <code>hardware.inc</code>, but we can also create our own for anything we want.
Let‚Äôs make three constants at the top of our file, representing the tile IDs of left bricks, right bricks, and blank tiles.</p>
<pre><code class="language-rgbasm linenos start=1">INCLUDE &quot;hardware.inc&quot;

DEF BRICK_LEFT EQU $05
DEF BRICK_RIGHT EQU $06
DEF BLANK_TILE EQU $08
</code></pre>
<p>Constants are a kind of <em>symbol</em> (which is to say, ‚Äúa thing with a name‚Äù).
Writing a constant‚Äôs name in an expression is equivalent to writing the number the constant is equal to, so <code>ld a, BRICK_LEFT</code> is the same as <code>ld a, $05</code>.
But I think we can all agree that the former is much clearer, right?</p>
<h2 id="destroying-bricks"><a class="header" href="#destroying-bricks">Destroying bricks</a></h2>
<p>Now we‚Äôll write a function that checks for and destroys bricks.
Our bricks are two tiles wide, so when we hit one we‚Äôll have to remove the adjacent tile as well.
If we hit the left side of a brick (represented by <code>BRICK_LEFT</code>), we need to remove it and the tile to its right (which should be the right side).
If we instead hit the right side, we need to remove the left!</p>
<pre><code class="language-rgbasm linenos start=282">; Checks if a brick was collided with and breaks it if possible.
; @param hl: address of tile.
CheckAndHandleBrick:
	ld a, [hl]
	cp a, BRICK_LEFT
	jr nz, CheckAndHandleBrickRight
	; Break a brick from the left side.
	ld [hl], BLANK_TILE
	inc hl
	ld [hl], BLANK_TILE
CheckAndHandleBrickRight:
	cp a, BRICK_RIGHT
	ret nz
	; Break a brick from the right side.
	ld [hl], BLANK_TILE
	dec hl
	ld [hl], BLANK_TILE
	ret
</code></pre>
<p>Just insert this function into each of your bounce checks now.
Make sure you don‚Äôt miss any!
It should go right <strong>before</strong> the momentum is modified.</p>
<pre><code class="language-diff linenos start=116">BounceOnTop:
	; Remember to offset the OAM position!
	; (8, 16) in OAM coordinates is (0, 0) on the screen.
	ld a, [_OAMRAM + 4]
	sub a, 16 + 1
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8
	ld b, a
	call GetTileByPixel ; Returns tile address in hl
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnRight
+	call CheckAndHandleBrick
	ld a, 1
	ld [wBallMomentumY], a

BounceOnRight:
	ld a, [_OAMRAM + 4]
	sub a, 16
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8 - 1
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnLeft
+	call CheckAndHandleBrick
	ld a, -1
	ld [wBallMomentumX], a

BounceOnLeft:
	ld a, [_OAMRAM + 4]
	sub a, 16
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8 + 1
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceOnBottom
+	call CheckAndHandleBrick
	ld a, 1
	ld [wBallMomentumX], a

BounceOnBottom:
	ld a, [_OAMRAM + 4]
	sub a, 16 - 1
	ld c, a
	ld a, [_OAMRAM + 5]
	sub a, 8
	ld b, a
	call GetTileByPixel
	ld a, [hl]
	call IsWallTile
	jp nz, BounceDone
+	call CheckAndHandleBrick
	ld a, -1
	ld [wBallMomentumY], a
BounceDone:
</code></pre>
<p>That‚Äôs it!
Pretty simple, right?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lavoro-in-corso"><a class="header" href="#lavoro-in-corso">Lavoro in corso</a></h1>
<div class="box warning">
<p class="box-title">üöß üöß üöß üöß üöß üöß üöß</p><p>Come spiegato nella presentazione iniziale del tutorial, la Parte ‚Ö° consiste nella costruzione di un gioco <em>Arkanoid</em>.
Tuttavia, questo non √® ancora finito; le lezioni vengono caricate man mano che vengono realizzate, quindi il tutorial si interrompe bruscamente a un certo punto.
Mi dispiace!</p>
<p>Tenete duro mentre ci lavoriamo, <a href="https://twitter.com/gbdev0">seguiteci su Twitter</a> per gli aggiornamenti e andate alla pagina successiva per scoprire cosa potete fare nel frattempo!</p>
<p>Grazie per la vostra pazienza üòä e ci vediamo su GBDev!</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prossimi-passi"><a class="header" href="#prossimi-passi">Prossimi passi</a></h1>
<p>Oh.
Bene, siete arrivati alla fine del tutorial‚Ä¶
E s√¨, come potete vedere, non √® ancora finito.
Stiamo lavorando attivamente per risolvere il problema, ma vi preghiamo di avere un po‚Äô di pazienza :)</p>
<p>Nel frattempo, la cosa migliore da fare √® consultare le <a href="resources.html">risorse</a> nella prossima sezione e sperimentare da soli.
Dato questo, potrebbe essere una buona idea <a href="help-feedback.html">chiedere in giro</a> per avere consigli.
Molti dei problemi e delle domande che incontrerete sono gi√† stati risolti, quindi altri possono - e lo faranno - aiutarvi a iniziare pi√π velocemente. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="risorse"><a class="header" href="#risorse">Risorse</a></h1>
<p>Ovvero ‚Äúdove andare da qui‚Äù.</p>
<h2 id="canali-di-aiuto"><a class="header" href="#canali-di-aiuto">Canali di aiuto</a></h2>
<ul>
<li><a href="https://gbdev.io">home page della comunit√† GBDev</a> e <a href="https://gbdev.io/chat">canali di chat</a>.</li>
</ul>
<h2 id="altri-tutorial"><a class="header" href="#altri-tutorial">Altri tutorial</a></h2>
<ul>
<li><a href="https://evie.gbdev.io/resources/interrupts">evie‚Äôs interrupts tutorial</a> should help you understand how to use interrupts, and what they are useful for.</li>
<li><a href="https://github.com/tbsp/simple-gb-asm-examples">tbsp‚Äôs ‚ÄúSimple GB ASM examples‚Äù</a> is a collection of ROMs, each built from a single, fairly short source file.
If you found this tutorial too abstract and/or want to get your feet wet, this is a good place to go to!</li>
<li><a href="https://github.com/daid/gameboy-assembly-by-example">GB assembly by example</a>, Daid‚Äôs collection of code snippets.
Consider this a continuation of the tutorial, but without explanations; it‚Äôs still useful to peruse them and ask about it, they are overall good quality.</li>
</ul>
<h2 id="complementi"><a class="header" href="#complementi">Complementi</a></h2>
<p>Vi √® piaciuto il tutorial o uno dei precedenti?
Quanto segue dovrebbe esservi utile per il resto del vostro viaggio!</p>
<ul>
<li>La <a href="https://rgbds.gbdev.io/docs/">documentazione online di RGBDS</a> √® sempre utile!
In particolare, troverete <a href="https://rgbds.gbdev.io/docs/gbz80.7">un riferimento alle istruzioni</a> e <a href="https://rgbds.gbdev.io/docs/rgbasm.5">il riferimento alla sintassi e alle caratteristiche di RGBASM</a>.</li>
<li>I <a href="https://gbdev.io/pandocs">Pan Docs</a> sono <em>il riferimento</em> per tutto l‚Äôhardware Game Boy.
√à una buona idea consultarlo se non si √® sicuri del funzionamento di un registro o se ci si chiede come fare qualcosa.</li>
<li><a href="https://gbdev.io/gb-opcodes/optables">gb-optables</a> √® una tabella di istruzioni pi√π compatta, che diventa pi√π utile quando non si ha pi√π bisogno delle descrizioni delle istruzioni.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ringraziamenti-speciali"><a class="header" href="#ringraziamenti-speciali">Ringraziamenti speciali</a></h1>
<p>Un grande ringraziamento a <a href="https://www.pouet.net/user.php?who=21982">Twoflower/Triad</a> per aver realizzato la grafica di Hello World.</p>
<p>Non ringrazier√≤ mai abbastanza Chlo√© e molti altri per il loro continuo sostegno.</p>
<p>Grazie alla comunit√† GBDev per essere stata cos√¨ gentile nel corso degli anni.</p>
<p><strong>Siete tutti fantastici. Grazie mille.</strong></p>
<hr />
<p>Si ringrazia il team di <a href="https://www.rust-lang.org">Rust language</a> per aver realizzato <a href="https://github.com/rust-lang/mdBook">mdBook</a>, che alimenta questo libro (questo design, onestamente elegante, √® quello di serie!!!).</p>
<p>Un saluto a AYCE, Phantasy, TPPDevs/RainbowDevs, Plutiedev, lft/kryo :)</p>
<p>Un saluto a <a href="https://eievui.ml">Eievui</a>, <a href="https://github.com/Rangi42">Rangi</a>, <a href="https://github.com/MarkSixtyFour">MarkSixtyFour</a>, <a href="https://github.com/aaaaaa123456789">ax6</a>, <a href="https://github.com/basxto">Ba≈ùto</a>, <a href="https://github.com/bbbbbr">bbbbbr</a> e <a href="https://github.com/bitnenfer">bitnenfer</a>!</p>
<p>The Italian translation is curated by <a href="https://github.com/Street-Philosopher">Antonio Guido Leoni</a>, <a href="https://github.com/avivace">Antonio Vivace</a>, <a href="https://github.com/MattiaFortunati">Mattia Fortunati</a> and <a href="https://github.com/mte90">Daniele Scasciafratte</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="js/linenos.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
